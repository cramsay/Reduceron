module Lava.Vhdl
  ( writeVhdl
  , writeVhdlForPart
  , Part(..)
  , xc3s200a
  , xc4vlx25
  , xc5vlx110t
  , xc6vlx75t
  ) where

import Lava.Bit
import Lava.Binary
import System.Process


vhdlGumpth :: String
vhdlGumpth = unlines $
  [ "-- Generated by York Lava for the XST"
  , ""
  , "library IEEE;"
  , "use IEEE.STD_LOGIC_1164.ALL;"
  , "use IEEE.NUMERIC_STD.ALL;"
  , ""
  , "library unisim;"
  , "use unisim.vcomponents.all;"
  , "library unimacro;"
  , "use unimacro.vcomponents.all;"
  , ""
  , "use work.all;"
  , ""
  ]

vhdlEntity :: String -> Netlist -> String
vhdlEntity name nl =
     "entity " ++ name ++ " is port (\n"
  ++ consperse ";\n"
       ([ v ++ " : out std_logic" | v <- outs]  ++
        [ "clock : in  std_logic"            ]  ++
        [ v ++ " : in  std_logic" | v <- inps])
  ++ "\n);\nend entity " ++ name ++ ";\n"
  where
    inps = [ lookupParam (netParams net) "name"
           | net <- nets nl, netName net == "name"]
    outs = map fst (namedOutputs nl)

{- |

For example:

> xc5vlx110t :: Part
> xc5vlx110t =
>   Part {
>     partName       = "xc5vlx110t"
>   , partFamily     = "virtex5"
>   , partPackage    = "ff1136"
>   , partSpeedGrade = "-1"
>   }

-}
data Part =
  Part {
    partName       :: String
  , partFamily     :: String
  , partPackage    :: String
  , partSpeedGrade :: String
  }

xc3s200a :: Part
xc3s200a =
  Part {
    partName       = "xc3s200a"
  , partFamily     = "spartan3a"
  , partPackage    = "vq100"
  , partSpeedGrade = "-4"
  }

xc4vlx25 :: Part
xc4vlx25 =
  Part {
    partName       = "xc4vlx25"
  , partFamily     = "virtex4"
  , partPackage    = "ff668"
  , partSpeedGrade = "-10C"
  }

xc5vlx110t :: Part
xc5vlx110t =
  Part {
    partName       = "xc5vlx110t"
  , partFamily     = "virtex5"
  , partPackage    = "ff1136"
  , partSpeedGrade = "-1"
  }

xc6vlx75t :: Part
xc6vlx75t =
  Part {
    partName       = "xc6vlx75t"
  , partFamily     = "virtex6"
  , partPackage    = "ff484"
  , partSpeedGrade = "-2"
  }

ramFile :: Part -> String -> String -> [Parameter] -> String
ramFile part name ramType params = unlines commands
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    primType = lookupParam params "primtype"

    coeFile = if null init then "no_coe_file_loaded"
                           else "init_" ++ name ++ ".txt"

    commands =
      ["set script_path [ file dirname [ file normalize [ info script ] ] ]"
      ,"set prj_dir [get_property DIRECTORY [current_project]]"
      ,"set prj_name [get_property NAME [current_project]]"
      ,"set xci_file $prj_dir/$prj_name.srcs/sources_1/ip/"++name++"/"++name++".xci"
      ,"create_ip -name blk_mem_gen -vendor xilinx.com -library ip -version 8.4 -module_name " ++ show name
      ,"set_property -dict [list \\"
      ,"    CONFIG.Memory_Type {" ++ (if ramType == "ram"
                                        then "Single_Port_RAM"
                                        else "True_Dual_Port_RAM") ++ "}\\"
      ,"    CONFIG.Algorithm {" ++ (if null primType
                                      then "Minimum_Area"
                                      else "Fixed_Primitives") ++ "}\\"
      ,"    CONFIG.Primitive {" ++ (if null primType
                                      then "8kx2"
                                      else primType) ++ "}\\"
      ,"    CONFIG.Write_Width_A {" ++ show dwidth ++ "}\\"
      ,"    CONFIG.Write_Depth_A {" ++ show (2^awidth) ++ "}\\"
      ,"    CONFIG.Read_Width_A {" ++ show dwidth ++ "}\\"
      ,"    CONFIG.Write_Width_B {" ++ show dwidth ++ "}\\"
      ,"    CONFIG.Read_Width_B {" ++ show dwidth ++ "}\\"
      ,"    CONFIG.Load_Init_File {" ++ (if coeFile == "no_coe_file_loaded"
                                           then "false"
                                           else "true") ++ "}\\"
      ,"    CONFIG.Coe_File \"$script_path/" ++ coeFile ++ "\"\\"
      ,"    CONFIG.PRIM_type_to_Implement {BRAM}\\"
      ,"    CONFIG.Enable_32bit_Address {false}\\"
      ,"    CONFIG.Use_Byte_Write_Enable {false}\\"
      ,"    CONFIG.Byte_Size {9}\\"
      ,"    CONFIG.Assume_Synchronous_Clk {true}\\"
      ,"    CONFIG.Operating_Mode_A {WRITE_FIRST}\\"
      ,"    CONFIG.Enable_A {Always_Enabled}\\"
      ,"    CONFIG.Operating_Mode_B {WRITE_FIRST}\\"
      ,"    CONFIG.Enable_B {Always_Enabled}\\"
      ,"    CONFIG.Register_PortA_Output_of_Memory_Primitives {false}\\"
      ,"    CONFIG.Register_PortB_Output_of_Memory_Primitives {false}\\"
      ,"    CONFIG.Use_RSTA_Pin {false}\\"
      ,"    CONFIG.Use_RSTB_Pin {false}\\"
      ,"    CONFIG.Port_A_Write_Rate {100}\\"
      ,"    CONFIG.Port_B_Clock {100}\\"
      ,"    CONFIG.Port_B_Write_Rate {100}\\"
      ,"    CONFIG.Port_B_Enable_Rate {100}\\"
      ,"    CONFIG.use_bram_block {Stand_Alone}\\"
      ,"    CONFIG.EN_SAFETY_CKT {false}] [get_ips " ++ name ++ "]"
      ,"generate_target all [get_ips " ++ name ++ "]"
      ,"update_compile_order -fileset sources_1"
      ]

vhdlDecls :: Netlist -> String
vhdlDecls nl =
     (consperse ",\n"
        [ consperse ",\n" $ map (wireStr . (,) (netId net))
                                [0..netNumOuts net-1]
        | net <- nets nl ])
  ++ " : std_logic;\n"
  ++ "attribute INIT: string;\n"
  ++ concat [ init (netId net) (netParams net)
            | net <- nets nl
            , netName net == "delay" || netName net == "delayEn" ]
  where
    init c params =
         "attribute INIT of " ++ compStr c ++ ": label is \""
      ++ lookupParam params "init" ++ "\";\n"

type Instantiator = String -> [Parameter] -> InstanceId -> [Wire] -> String

vhdlInsts :: Instantiator -> Netlist -> String
vhdlInsts f nl =
  concat [ f (netName net)
             (netParams net)
             (netId net)
             (netInputs net)
         | net <- nets nl ] ++
  concat [ s ++ " <= " ++ wireStr w ++ ";\n"
         | (s, w) <- namedOutputs nl ]

vhdlInst :: Instantiator
vhdlInst "low"     = constant "'0'"
vhdlInst "high"    = constant "'1'"
vhdlInst "inv"     = lut1 "1" 1
vhdlInst "and2"    = lut2 "8" 1
vhdlInst "or2"     = lut2 "E" 1
vhdlInst "xor2"    = lut2 "6" 1
vhdlInst "eq2"     = lut2 "9" 1
vhdlInst "xorcy"   = error "XORCY nor supported" -- lut2 "6" 1
vhdlInst "muxcy"   = error "MUXCY not supported" --gate 1 "muxf7"
vhdlInst "name"    = assignName
vhdlInst "delay"   = delay (const "'1'") "fdce"
vhdlInst "delayEn" = delay (wireStr . head . tail) "fdce"
vhdlInst "ram"     = instRam
vhdlInst "dualRam" = instRam2
vhdlInst "add"   = addsubClb "+"
                   --addsubDsp False
vhdlInst "sub"   = addsubClb "-"
                   --addsubDsp True
vhdlInst s = error ("Vhdl: unknown component '" ++ s ++ "'")

vhdlArch :: Instantiator -> String -> Netlist -> String
vhdlArch f name nl =
     "architecture structural of " ++ name ++ " is\n"
  ++ "signal " ++ vhdlDecls nl
  ++ "begin\n"
  ++ vhdlInsts f nl
  ++ "end structural;\n"

ramFiles :: Part -> Netlist -> [(String, String)]
ramFiles part nl = concat
    [ (ramName ++ ".tcl", ramFile part ramName (netName net) params)
      :
      if nonEmpty params then
         [("init_" ++ ramName ++ ".txt", genCoeFile params)]
      else
         []
    | net <- nets nl
    , netName net == "ram" || netName net == "dualRam"
    , let ramName = "ram_" ++ ramAnnotation net ++ compStr (netId net)
          params = netParams net
    ]
  where
    ramAnnotation net = "" -- lookupParam (netParams net) "annotation"
    nonEmpty params = not (null init)
      where init = read (lookupParam params "init") :: [Integer]

    genCoeFile params =
         "memory_initialization_radix = 10;\n"
      ++ "memory_initialization_vector = "
      ++ (unwords $ map show init)
      ++ ";\n"
     where init = read (lookupParam params "init") :: [Integer]

vhdl :: Part -> String -> Netlist -> [(String, String)]
vhdl part name nl =
  [ (name ++ ".vhd", vhdlGumpth
                  ++ vhdlEntity name nl
                  ++ vhdlArch vhdlInst name nl) ] ++ ramFiles part nl

{-|

For example, the function

> halfAdd :: Bit -> Bit -> (Bit, Bit)
> halfAdd a b = (sum, carry)
>   where
>     sum   = a <#> b
>     carry = a <&> b

can be converted to a VHDL entity with inputs named @a@ and @b@ and
outputs named @sum@ and @carry@.

> synthesiseHalfAdd :: IO ()
> synthesiseHalfAdd =
>   writeVhdl "HalfAdd"
>             (halfAdd (name "a") (name "b"))
>             (name "sum", name "carry")

The function 'writeVhdl' assumes that the part (FPGA chip) you are
targetting is the @Virtex-5-110t-ff1136-1@, because that is what sits
at my desk.  This is /only/ important if your design contains RAMs.
If your design does contain RAMs, and you wish to target a different
part, then use the 'writeVhdlForPart' function.  Xilinx's fault!

-}
writeVhdl ::
  Generic a => String -- ^ The name of VHDL entity, which is also the
                      -- name of the directory that the output files
                      -- are written to.
            -> a      -- ^ The Bit-structure that is turned into VHDL.
            -> a      -- ^ Names for the outputs of the circuit.
            -> IO ()
writeVhdl = writeVhdlForPart xc5vlx110t

-- | Like 'writeVhdl', but allows the target part (FPGA chip) to be specified.
writeVhdlForPart ::
  Generic a => Part   -- ^ Part (FPGA chip) being targetted.
            -> String -- ^ The name of VHDL entity, which is also the
                      -- name of the directory that the output files
                      -- are written to.
            -> a      -- ^ The Bit-structure that is turned into VHDL.
            -> a      -- ^ Names for the outputs of the circuit.
            -> IO ()
writeVhdlForPart part name a b =
  do putStrLn ("Creating directory '" ++ name ++ "/'")
     callProcess "mkdir" ["-p", name]
     nl <- netlist a b
     mapM_ gen (vhdl part name nl)
     putStrLn "Done."
  where
    gen (file, content) =
      do putStrLn $ "Writing to '" ++ name ++ "/" ++ file ++ "'"
         writeFile (name ++ "/" ++ file) content

-- Auxiliary functions

compStr :: InstanceId -> String
compStr i = "c" ++ show i

wireStr :: Wire -> String
wireStr (i, 0) = "w" ++ show i
wireStr (i, j) = "w" ++ show i ++ "_" ++ show j

consperse :: String -> [String] -> String
consperse s [] = ""
consperse s [x] = x
consperse s (x:y:ys) = x ++ s ++ consperse s (y:ys)

argList :: [String] -> String
argList = consperse ","

gate n str params comp inps =
  compStr comp ++ " : " ++ str ++ " port map (" ++ argList (xs ++ ys) ++ ");\n"
  where xs = map (\i -> wireStr (comp, i)) [0..n-1]
        ys = map wireStr inps

lut1 init n params comp inps =
  compStr comp ++ " : lut1 generic map (INIT => x\"" ++ init ++
    "\") port map (" ++ argList (xs ++ ys) ++ ");\n"
  where xs = map (\i -> wireStr (comp, i)) [0..n-1]
        ys = map wireStr inps

lut2 init n params comp inps =
  compStr comp ++ " : lut2 generic map (INIT => x\"" ++ init ++
    "\") port map (" ++ argList (xs ++ ys) ++ ");\n"
  where xs = map (\i -> wireStr (comp, i)) [0..n-1]
        ys = map wireStr inps

assignName params comp inps =
  wireStr (comp, 0)  ++ " <= " ++ lookupParam params "name" ++ ";\n"

muxBit params comp [b, a, sel] =
  "with " ++ wireStr sel ++ " select "
          ++ wireStr (comp, 0)  ++ " <= " ++ wireStr a ++ " when '0',"
                                ++ wireStr b ++ " when '1';\n"

constant str params comp inps =
  wireStr (comp, 0) ++ " <= " ++ str ++ ";\n"

delay enF str params comp inps =
  compStr comp ++ " : " ++ str
               ++ " generic map (INIT => '"
               ++ lookupParam params "init" ++ "') "
               ++ "port map ("
               ++ argList (wireStr (comp, 0) :
                    "clock" : enF inps : "'0'" : wireStr (last inps) : [])
               ++ ");\n"

addsubDsp flag params comp sigs =
  compStr comp ++ " : ADDSUB_MACRO generic map (LATENCY => 0, WIDTH => " ++ show (1 + length ina) ++
    ") port map ( clk => clock, rst => '0', carryin => '0', ce => '1', add_sub => '" ++ opType ++ "', "
                  ++ argList (busMap "a" $ ina ++ [last ina]) ++ ","
                  ++ argList (busMap "b" $ inb ++ [last inb]) ++ ","
                  ++ argList (busMap "result" outs1) -- ++ ","
                  -- ++ "carryout => " ++ (wireStr (comp,width))
                  ++ ");\n"
  where
    opType = if flag then "0"
                     else "1"

    width = read (lookupParam params "awidth") :: Int
    (ina, inb) = splitAt width sigs
    outs1          = map ((,) comp) [0..width]

addsubClb op params comp sigs =
  "(" ++ consperse ", " (map wireStr $ reverse outs1)
  ++ ") <= std_logic_vector( "
  ++ "resize(signed'(" ++ consperse " & " (map wireStr $ reverse ina) ++ "), " ++ show (owidth) ++ ")"
  ++ op
  ++ "resize(signed'(" ++ consperse " & " (map wireStr $ reverse inb) ++ "), " ++ show (owidth) ++ ")"
  ++ ");\n"
  where
    owidth = read (lookupParam params "owidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    bwidth = read (lookupParam params "bwidth") :: Int
    (ina, inb) = splitAt awidth sigs
    outs1          = map ((,) comp) [0..owidth-1]

-- Block ram synthesis for Virtex 5 using Xilinx core-generator

busMap :: String -> [Wire] -> [String]
busMap port signals =
  zipWith (\i s -> port ++ "(" ++ show i ++ ") => " ++ wireStr s) [0..] signals

instRam params comp (we:sigs) =
    compStr comp ++ " : entity ram_" ++ compStr comp ++ " "
                 ++ " port map ("
                 ++ " clka => clock, "
                 ++ argList (busMap "dina" dbus1) ++ ","
                 ++ argList (busMap "addra" abus1) ++ ","
                 ++ " wea(0) => " ++ wireStr we ++ ","
                 ++ argList (busMap "douta" outs1)
                 ++ ");\n"
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    primType = lookupParam params "primtype"

    (dbus1, abus1) = splitAt dwidth sigs
    outs1          = map ((,) comp) [0..dwidth-1]

instRam2 params comp (we1:we2:sigs) =
    compStr comp ++ " : entity ram_" ++ compStr comp ++ " "
                 ++ " port map ("
                 ++ " clka => clock, "
                 ++ argList (busMap "dina" dbus1) ++ ","
                 ++ argList (busMap "addra" abus1) ++ ","
                 ++ " wea(0) => " ++ wireStr we1 ++ ","
                 ++ argList (busMap "douta" outs1) ++ ","
                 ++ " clkb => clock, "
                 ++ argList (busMap "dinb" dbus2) ++ ","
                 ++ argList (busMap "addrb" abus2) ++ ","
                 ++ " web(0) => " ++ wireStr we2 ++ ","
                 ++ argList (busMap "doutb" outs2)
                 ++ ");\n"
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    primType = lookupParam params "primtype"

    (dbus, abus)   = splitAt (2*dwidth) sigs
    (abus1, abus2) = splitAt awidth abus
    (dbus1, dbus2) = splitAt dwidth dbus
    outs1          = map ((,) comp) [0..dwidth-1]
    outs2          = map ((,) comp) [dwidth..dwidth*2-1]
