module Lava.Vhdl
  ( writeVhdl
  , writeVhdlForPart
  , Part(..)
  , xc3s200a
  , xc4vlx25
  , xc5vlx110t
  , xc6vlx75t
  ) where

import Lava.Bit
import Lava.Binary
import System.Process
import Numeric (showHex)

hexify :: [Integer] -> String
hexify = unlines . map (flip showHex "")

vhdlGumpth :: String
vhdlGumpth = unlines $
  [ "-- Generated by York Lava for the XST"
  , ""
  , "library IEEE;"
  , "use IEEE.STD_LOGIC_1164.ALL;"
  , "use IEEE.NUMERIC_STD.ALL;"
  , ""
  , "library unisim;"
  , "use unisim.vcomponents.all;"
  , "library unimacro;"
  , "use unimacro.vcomponents.all;"
  , "library xpm;"
  , "use xpm.vcomponents.all;"
  , ""
  , "use work.all;"
  , ""
  ]

vhdlEntity :: String -> Netlist -> String
vhdlEntity name nl =
     "entity " ++ name ++ " is port (\n"
  ++ consperse ";\n"
       ([ v ++ " : out std_logic" | v <- outs]  ++
        [ "clock : in  std_logic"            ]  ++
        [ v ++ " : in  std_logic" | v <- inps])
  ++ "\n);\nend entity " ++ name ++ ";\n"
  where
    inps = [ lookupParam (netParams net) "name"
           | net <- nets nl, netName net == "name"]
    outs = map fst (namedOutputs nl)

{- |

For example:

> xc5vlx110t :: Part
> xc5vlx110t =
>   Part {
>     partName       = "xc5vlx110t"
>   , partFamily     = "virtex5"
>   , partPackage    = "ff1136"
>   , partSpeedGrade = "-1"
>   }

-}
data Part =
  Part {
    partName       :: String
  , partFamily     :: String
  , partPackage    :: String
  , partSpeedGrade :: String
  }

xc3s200a :: Part
xc3s200a =
  Part {
    partName       = "xc3s200a"
  , partFamily     = "spartan3a"
  , partPackage    = "vq100"
  , partSpeedGrade = "-4"
  }

xc4vlx25 :: Part
xc4vlx25 =
  Part {
    partName       = "xc4vlx25"
  , partFamily     = "virtex4"
  , partPackage    = "ff668"
  , partSpeedGrade = "-10C"
  }

xc5vlx110t :: Part
xc5vlx110t =
  Part {
    partName       = "xc5vlx110t"
  , partFamily     = "virtex5"
  , partPackage    = "ff1136"
  , partSpeedGrade = "-1"
  }

xc6vlx75t :: Part
xc6vlx75t =
  Part {
    partName       = "xc6vlx75t"
  , partFamily     = "virtex6"
  , partPackage    = "ff484"
  , partSpeedGrade = "-2"
  }

vhdlDecls :: Netlist -> String
vhdlDecls nl =
     (consperse ",\n"
        [ consperse ",\n" $ map (wireStr . (,) (netId net))
                                [0..netNumOuts net-1]
        | net <- nets nl ])
  ++ " : std_logic;\n"
  ++ "attribute INIT: string;\n"
  ++ concat [ init (netId net) (netParams net)
            | net <- nets nl
            , netName net == "delay" || netName net == "delayEn" ]
  where
    init c params =
         "attribute INIT of " ++ compStr c ++ ": label is \""
      ++ lookupParam params "init" ++ "\";\n"

type Instantiator = String -> [Parameter] -> InstanceId -> [Wire] -> String

vhdlInsts :: Instantiator -> Netlist -> String
vhdlInsts f nl =
  concat [ f (netName net)
             (netParams net)
             (netId net)
             (netInputs net)
         | net <- nets nl ] ++
  concat [ s ++ " <= " ++ wireStr w ++ ";\n"
         | (s, w) <- namedOutputs nl ]

vhdlInst :: Instantiator
vhdlInst "low"     = constant "'0'"
vhdlInst "high"    = constant "'1'"
vhdlInst "inv"     = lut1 "1" 1
vhdlInst "and2"    = lut2 "8" 1
vhdlInst "or2"     = lut2 "E" 1
vhdlInst "xor2"    = lut2 "6" 1
vhdlInst "eq2"     = lut2 "9" 1
vhdlInst "xorcy"   = error "XORCY nor supported" -- lut2 "6" 1
vhdlInst "muxcy"   = error "MUXCY not supported" --gate 1 "muxf7"
vhdlInst "name"    = assignName
vhdlInst "delay"   = delay (const "'1'") "fdce"
vhdlInst "delayEn" = delay (wireStr . head . tail) "fdce"
vhdlInst "ram"     = instRam
vhdlInst "dualRam" = instRam2
vhdlInst "add"   = addsubClb "+"
                   --addsubDsp False
vhdlInst "sub"   = addsubClb "-"
                   --addsubDsp True
vhdlInst s = error ("Vhdl: unknown component '" ++ s ++ "'")

vhdlArch :: Instantiator -> String -> Netlist -> String
vhdlArch f name nl =
     "architecture structural of " ++ name ++ " is\n"
  ++ "signal " ++ vhdlDecls nl
  ++ "begin\n"
  ++ vhdlInsts f nl
  ++ "end structural;\n"

ramFiles :: Part -> Netlist -> [(String, String)]
ramFiles part nl = concat
    [if nonEmpty params then
         [("init_" ++ ramName ++ ".mem", genCoeFile params)]
        else
         []
    | net <- nets nl
    , netName net == "ram" || netName net == "dualRam"
    , let ramName = "ram_" ++ ramAnnotation net ++ compStr (netId net)
          params = netParams net
    ]
  where
    ramAnnotation net = "" -- lookupParam (netParams net) "annotation"
    nonEmpty params = not (null init)
      where init = read (lookupParam params "init") :: [Integer]

    genCoeFile params = hexify init
     where init = read (lookupParam params "init") :: [Integer]

vhdl :: Part -> String -> Netlist -> [(String, String)]
vhdl part name nl =
  [ (name ++ ".vhd", vhdlGumpth
                  ++ vhdlEntity name nl
                  ++ vhdlArch vhdlInst name nl) ] ++ ramFiles part nl

{-|

For example, the function

> halfAdd :: Bit -> Bit -> (Bit, Bit)
> halfAdd a b = (sum, carry)
>   where
>     sum   = a <#> b
>     carry = a <&> b

can be converted to a VHDL entity with inputs named @a@ and @b@ and
outputs named @sum@ and @carry@.

> synthesiseHalfAdd :: IO ()
> synthesiseHalfAdd =
>   writeVhdl "HalfAdd"
>             (halfAdd (name "a") (name "b"))
>             (name "sum", name "carry")

The function 'writeVhdl' assumes that the part (FPGA chip) you are
targetting is the @Virtex-5-110t-ff1136-1@, because that is what sits
at my desk.  This is /only/ important if your design contains RAMs.
If your design does contain RAMs, and you wish to target a different
part, then use the 'writeVhdlForPart' function.  Xilinx's fault!

-}
writeVhdl ::
  Generic a => String -- ^ The name of VHDL entity, which is also the
                      -- name of the directory that the output files
                      -- are written to.
            -> a      -- ^ The Bit-structure that is turned into VHDL.
            -> a      -- ^ Names for the outputs of the circuit.
            -> IO ()
writeVhdl = writeVhdlForPart xc5vlx110t

-- | Like 'writeVhdl', but allows the target part (FPGA chip) to be specified.
writeVhdlForPart ::
  Generic a => Part   -- ^ Part (FPGA chip) being targetted.
            -> String -- ^ The name of VHDL entity, which is also the
                      -- name of the directory that the output files
                      -- are written to.
            -> a      -- ^ The Bit-structure that is turned into VHDL.
            -> a      -- ^ Names for the outputs of the circuit.
            -> IO ()
writeVhdlForPart part name a b =
  do putStrLn ("Creating directory '" ++ name ++ "/'")
     callProcess "mkdir" ["-p", name]
     nl <- netlist a b
     mapM_ gen (vhdl part name nl)
     putStrLn "Done."
  where
    gen (file, content) =
      do putStrLn $ "Writing to '" ++ name ++ "/" ++ file ++ "'"
         writeFile (name ++ "/" ++ file) content

-- Auxiliary functions

compStr :: InstanceId -> String
compStr i = "c" ++ show i

wireStr :: Wire -> String
wireStr (i, 0) = "w" ++ show i
wireStr (i, j) = "w" ++ show i ++ "_" ++ show j

consperse :: String -> [String] -> String
consperse s [] = ""
consperse s [x] = x
consperse s (x:y:ys) = x ++ s ++ consperse s (y:ys)

argList :: [String] -> String
argList = consperse ","

gate n str params comp inps =
  compStr comp ++ " : " ++ str ++ " port map (" ++ argList (xs ++ ys) ++ ");\n"
  where xs = map (\i -> wireStr (comp, i)) [0..n-1]
        ys = map wireStr inps

lut1 init n params comp inps =
  compStr comp ++ " : lut1 generic map (INIT => x\"" ++ init ++
    "\") port map (" ++ argList (xs ++ ys) ++ ");\n"
  where xs = map (\i -> wireStr (comp, i)) [0..n-1]
        ys = map wireStr inps

lut2 init n params comp inps =
  compStr comp ++ " : lut2 generic map (INIT => x\"" ++ init ++
    "\") port map (" ++ argList (xs ++ ys) ++ ");\n"
  where xs = map (\i -> wireStr (comp, i)) [0..n-1]
        ys = map wireStr inps

assignName params comp inps =
  wireStr (comp, 0)  ++ " <= " ++ lookupParam params "name" ++ ";\n"

muxBit params comp [b, a, sel] =
  "with " ++ wireStr sel ++ " select "
          ++ wireStr (comp, 0)  ++ " <= " ++ wireStr a ++ " when '0',"
                                ++ wireStr b ++ " when '1';\n"

constant str params comp inps =
  wireStr (comp, 0) ++ " <= " ++ str ++ ";\n"

delay enF str params comp inps =
  compStr comp ++ " : " ++ str
               ++ " generic map (INIT => '"
               ++ lookupParam params "init" ++ "') "
               ++ "port map ("
               ++ argList (wireStr (comp, 0) :
                    "clock" : enF inps : "'0'" : wireStr (last inps) : [])
               ++ ");\n"

addsubDsp flag params comp sigs =
  compStr comp ++ " : ADDSUB_MACRO generic map (LATENCY => 0, WIDTH => " ++ show (1 + length ina) ++
    ") port map ( clk => clock, rst => '0', carryin => '0', ce => '1', add_sub => '" ++ opType ++ "', "
                  ++ argList (busMap "a" $ ina ++ [last ina]) ++ ","
                  ++ argList (busMap "b" $ inb ++ [last inb]) ++ ","
                  ++ argList (busMap "result" outs1) -- ++ ","
                  -- ++ "carryout => " ++ (wireStr (comp,width))
                  ++ ");\n"
  where
    opType = if flag then "0"
                     else "1"

    width = read (lookupParam params "awidth") :: Int
    (ina, inb) = splitAt width sigs
    outs1          = map ((,) comp) [0..width]

addsubClb op params comp sigs =
  "(" ++ consperse ", " (map wireStr $ reverse outs1)
  ++ ") <= std_logic_vector( "
  ++ "resize(signed'(" ++ consperse " & " (map wireStr $ reverse ina) ++ "), " ++ show (owidth) ++ ")"
  ++ op
  ++ "resize(signed'(" ++ consperse " & " (map wireStr $ reverse inb) ++ "), " ++ show (owidth) ++ ")"
  ++ ");\n"
  where
    owidth = read (lookupParam params "owidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    bwidth = read (lookupParam params "bwidth") :: Int
    (ina, inb) = splitAt awidth sigs
    outs1          = map ((,) comp) [0..owidth-1]

-- Block ram synthesis for Virtex 5 using Xilinx core-generator

busMap :: String -> [Wire] -> [String]
busMap port signals =
  zipWith (\i s -> port ++ "(" ++ show i ++ ") => " ++ wireStr s) [0..] signals

instRam params comp (we:sigs) = unlines commands
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    resourceType = lookupParam params "resourceType"
    coeFile = if null init then "none"
                           else "init_ram_" ++ compStr comp ++ ".mem"
    (dbus1, abus1) = splitAt dwidth sigs
    outs1          = map ((,) comp) [0..dwidth-1]

    commands =
      [compStr comp ++ " : xpm_memory_spram generic map ("
      ,"  ADDR_WIDTH_A => " ++ show awidth ++ ","
      ,"  AUTO_SLEEP_TIME => 0,"
      ,"  BYTE_WRITE_WIDTH_A => " ++ show dwidth ++ ","
      ,"  ECC_MODE => \"no_ecc\","
      ,"  MEMORY_INIT_FILE => " ++ show coeFile ++ ","
      ,"  MEMORY_OPTIMIZATION => \"true\","
      ,"  MEMORY_PRIMITIVE => " ++ show resourceType ++ ","
      ,"  MEMORY_SIZE => " ++ show (dwidth * 2^awidth) ++ ","
      ,"  MESSAGE_CONTROL => 0,"
      ,"  READ_DATA_WIDTH_A => " ++ show dwidth ++ ","
      ,"  READ_LATENCY_A => 1,"
      ,"  RST_MODE_A => \"SYNC\","
      ,"  USE_MEM_INIT => " ++ (if null init
                                  then "0,"
                                  else "1,")
      ,"  WAKEUP_TIME => \"disable_sleep\","
      ,"  WRITE_DATA_WIDTH_A => " ++ show dwidth ++ ","
      ,"  WRITE_MODE_A => \"write_first\")"

      ,"  port map ("
      , " clka => clock, "
      , "  " ++ argList (busMap "dina" dbus1) ++ ","
      , "  " ++ argList (busMap "addra" abus1) ++ ","
      , "  wea(0) => " ++ wireStr we ++ ","
      , "  " ++ argList (busMap "douta" outs1) ++ ","
      , "  injectdbiterra => '0', "
      , "  injectsbiterra => '0', "
      , "  regcea => '0', "
      , "  rsta => '0', "
      , "  sleep => '0', "
      , "  ena => '1' "
      , ");"
      ]

instRam2 params comp (we1:we2:sigs) = unlines commands
  where
    init = read (lookupParam params "init") :: [Integer]
    dwidth = read (lookupParam params "dwidth") :: Int
    awidth = read (lookupParam params "awidth") :: Int
    resourceType = lookupParam params "resourceType"
    coeFile = if null init then "none"
                           else "init_ram_" ++ compStr comp ++ ".mem"
    (dbus, abus)   = splitAt (2*dwidth) sigs
    (abus1, abus2) = splitAt awidth abus
    (dbus1, dbus2) = splitAt dwidth dbus
    outs1          = map ((,) comp) [0..dwidth-1]
    outs2          = map ((,) comp) [dwidth..dwidth*2-1]

    commands =
      [compStr comp ++ " : xpm_memory_tdpram generic map ("
      ,"  AUTO_SLEEP_TIME => 0,"
      ,"  ECC_MODE => \"no_ecc\","
      ,"  MEMORY_INIT_FILE => " ++ show coeFile ++ ","
      ,"  MEMORY_OPTIMIZATION => \"true\","
      ,"  MEMORY_PRIMITIVE => " ++ show resourceType ++ ","
      ,"  MEMORY_SIZE => " ++ show (dwidth * 2^awidth) ++ ","
      ,"  MESSAGE_CONTROL => 0,"
      ,"  ADDR_WIDTH_A => " ++ show awidth ++ ","
      ,"  BYTE_WRITE_WIDTH_A => " ++ show dwidth ++ ","
      ,"  READ_DATA_WIDTH_A => " ++ show dwidth ++ ","
      ,"  READ_LATENCY_A => 1,"
      ,"  RST_MODE_A => \"SYNC\","
      ,"  WRITE_DATA_WIDTH_A => " ++ show dwidth ++ ","
      ,"  WRITE_MODE_A => " ++ show (if resourceType == "ultra" then "no_change" else "write_first") ++  ","
      ,"  ADDR_WIDTH_B => " ++ show awidth ++ ","
      ,"  BYTE_WRITE_WIDTH_B => " ++ show dwidth ++ ","
      ,"  READ_DATA_WIDTH_B => " ++ show dwidth ++ ","
      ,"  READ_LATENCY_B => 1,"
      ,"  RST_MODE_B => \"SYNC\","
      ,"  WRITE_DATA_WIDTH_B => " ++ show dwidth ++ ","
      ,"  WRITE_MODE_B => " ++ show (if resourceType == "ultra" then "no_change" else "write_first") ++  ","
      ,"  USE_MEM_INIT => " ++ (if null init
                                  then "0,"
                                  else "1,")
      ,"  WAKEUP_TIME => \"disable_sleep\","
      ,"  CLOCKING_MODE => \"common_clock\"" -- Allows URAM inference
      ,"  )"

      ,"  port map ("
      , " clka => clock, "
      , "  " ++ argList (busMap "dina" dbus1) ++ ","
      , "  " ++ argList (busMap "addra" abus1) ++ ","
      , "  wea(0) => " ++ wireStr we1 ++ ","
      , "  " ++ argList (busMap "douta" outs1) ++ ","
      , "  injectdbiterra => '0', "
      , "  injectsbiterra => '0', "
      , "  regcea => '0', "
      , "  rsta => '0', "
      , "  ena => '1', "
      , " clkb => clock, "
      , "  " ++ argList (busMap "dinb" dbus2) ++ ","
      , "  " ++ argList (busMap "addrb" abus2) ++ ","
      , "  web(0) => " ++ wireStr we2 ++ ","
      , "  " ++ argList (busMap "doutb" outs2) ++ ","
      , "  injectdbiterrb => '0', "
      , "  injectsbiterrb => '0', "
      , "  regceb => '0', "
      , "  rstb => '0', "
      , "  sleep => '0', "
      , "  enb => '1' "
      , ");"
      ]
