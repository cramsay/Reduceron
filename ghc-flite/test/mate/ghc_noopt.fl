{
id x = x;
const c x = c;
inc n = (+) n 1;
dec n = (-) n 1;
onFor ds2 eta = case ds2 of { Black -> inc eta; White -> dec eta };
min x y = case (<=) x y of { False -> y; True -> x };
max x y = case (<=) x y of { False -> x; True -> y };
abs n = case (<=) n 0 of { False -> n; True -> (-) 0 n };
plus a1 b = (+) a1 b;
minus a1 b = (-) a1 b;
no ds2 = case ds2 of { Nothing -> True; Just ds3 -> False };
maybe n j ds2 = case ds2 of { Nothing -> n; Just x -> j x };
not ds2 = case ds2 of { False -> True; True -> False };
and ds2 ds3 = case ds2 of { False -> False; True -> ds3 };
or ds2 ds3 = case ds2 of { False -> ds3; True -> True };
con ds2 q = case ds2 of { False -> False; True -> q };
sameSquare ds2 ds3 = case ds2 of { MkTup f1 r1 -> case ds3 of { MkTup f2 r2 -> case (==) f1 f2 of { False -> False; True -> (==) r1 r2 } } };
pieceAtWith eta eta1 eta2 eta3 = let { pieceAtWith1 = pieceAtWithLiftA0 } in pieceAtWith1 eta eta1 eta2 eta3;
pieceAtWithLiftA0 sq c n ds2 = case ds2 of { Nil -> n; Cons ds3 xs -> case ds3 of { MkTup k s -> case s of { MkTup f1 r1 -> case sq of { MkTup f2 r2 -> case (==) f1 f2 of { False -> pieceAtWithLiftA0 sq c n xs; True -> case (==) r1 r2 of { False -> pieceAtWithLiftA0 sq c n xs; True -> Just (MkTup c k) } } } } } };
pieceAt ds2 sq = case ds2 of { Board wkss bkss -> pieceAtWith sq White (pieceAtWith sq Black Nothing bkss) wkss };
rPa eta eta1 = let { rPa1 = rPaLiftA0 } in rPa1 eta eta1;
rPaLiftA0 sq ds2 = case ds2 of { Nil -> Nil; Cons ks kss -> case ks of { MkTup k s -> case s of { MkTup f1 r1 -> case sq of { MkTup f2 r2 -> case (==) f1 f2 of { False -> Cons ks (rPaLiftA0 sq kss); True -> case (==) r1 r2 of { False -> Cons ks (rPaLiftA0 sq kss); True -> kss } } } } } };
rmPieceAt ds2 sq ds3 = case ds2 of { Black -> case ds3 of { Board wkss bkss -> Board wkss (rPa sq bkss) }; White -> case ds3 of { Board wkss bkss -> Board (rPa sq wkss) bkss } };
onboard ds2 = case ds2 of { MkTup p q -> case (<=) 1 p of { False -> False; True -> case (<=) p 8 of { False -> False; True -> case (<=) 1 q of { False -> False; True -> (<=) q 8 } } } };
filePath xk yFrom yTo ds2 = case ds2 of { MkTup x y -> case (==) x xk of { False -> False; True -> case (<=) ((+) case (<=) yFrom yTo of { False -> yTo; True -> yFrom } 1) y of { False -> False; True -> (<=) y ((-) case (<=) yFrom yTo of { False -> yFrom; True -> yTo } 1) } } };
rankPath yk xFrom xTo ds2 = case ds2 of { MkTup x y -> case (==) y yk of { False -> False; True -> case (<=) ((+) case (<=) xFrom xTo of { False -> xTo; True -> xFrom } 1) x of { False -> False; True -> (<=) x ((-) case (<=) xFrom xTo of { False -> xFrom; True -> xTo } 1) } } };
diagPath op d xFrom xTo ds2 = case ds2 of { MkTup x y -> case (==) (op x y) d of { False -> False; True -> case (<=) ((+) case (<=) xFrom xTo of { False -> xTo; True -> xFrom } 1) x of { False -> False; True -> (<=) x ((-) case (<=) xFrom xTo of { False -> xFrom; True -> xTo } 1) } } };
dis ds2 q = case ds2 of { False -> q; True -> True };
any p ds2 = case ds2 of { Nil -> False; Cons x xs -> case p x of { False -> any p xs; True -> True } };
fst ds2 = case ds2 of { MkTup x y -> x };
snd ds2 = case ds2 of { MkTup x y -> y };
unzip ds2 = case ds2 of { Nil -> MkTup Nil Nil; Cons ds3 xs -> case ds3 of { MkTup a2 b -> let { u = unzip xs } in MkTup (Cons a2 case u of { MkTup x y -> x }) (Cons b case u of { MkTup x y -> y }) } };
cross ds2 ds3 = case ds2 of { MkTup f g -> case ds3 of { MkTup x y -> MkTup (f x) (g y) } };
null ds2 = case ds2 of { Nil -> True; Cons x xs -> False };
append ds2 ys = case ds2 of { Nil -> ys; Cons x xs -> Cons x (append xs ys) };
concatMap f ds2 = case ds2 of { Nil -> Nil; Cons x xs -> append (f x) (concatMap f xs) };
elemAt eta eta1 = let { elemAt1 = elemAtLiftA0 } in elemAt1 eta eta1;
elemAtLiftA0 ds2 n = case ds2 of { Nil -> 0; Cons x xs -> case (==) n 0 of { False -> elemAtLiftA0 xs ((-) n 1); True -> x } };
map f ds2 = case ds2 of { Nil -> Nil; Cons x xs -> Cons (f x) (map f xs) };
foldr f z ds2 = case ds2 of { Nil -> z; Cons x xs -> f x (foldr f z xs) };
sumAcc eta eta1 = let { sumAcc1 = sumAccLiftA0 } in sumAcc1 eta eta1;
sumAccLiftA0 acc ds2 = case ds2 of { Nil -> acc; Cons x xs -> sumAccLiftA0 ((+) acc x) xs };
sum xs = let { sumAcc1 = sumLiftA0 } in sumAcc1 0 xs;
sumLiftA0 acc ds2 = case ds2 of { Nil -> acc; Cons x xs1 -> sumLiftA0 ((+) acc x) xs1 };
size eta = let { size1 = sizeLiftA0 } in size1 eta;
sizeLiftA0 ds2 = case ds2 of { Solution mif rs -> (+) 1 (sum (map sizeLiftA0 case unzip rs of { MkTup x y -> y })) };
showResult ds2 = case ds2 of { Nothing -> 0; Just s -> size s };
kindToChar ds2 = case ds2 of { King -> 'K'; Queen -> 'Q'; Rook -> 'R'; Bishop -> 'B'; Knight -> 'N'; Pawn -> 'P' };
isKing k = (==) case k of { King -> 'K'; Queen -> 'Q'; Rook -> 'R'; Bishop -> 'B'; Knight -> 'N'; Pawn -> 'P' } ('K');
kSq eta = let { kSq1 = kSqLiftA0 } in kSq1 eta;
kSqLiftA0 ds2 = case ds2 of { Nil -> MkTup 0 0; Cons ds3 kss -> case ds3 of { MkTup k s -> case isKing k of { False -> kSqLiftA0 kss; True -> s } } };
emptyAtAllAnd e b ds2 = case ds2 of { Nil -> b; Cons ds3 xs -> case ds3 of { MkTup k s -> case e s of { False -> emptyAtAllAnd e b xs; True -> False } } };
emptyAtAll ds2 e = case ds2 of { Board wkss bkss -> emptyAtAllAnd e (emptyAtAllAnd e True bkss) wkss };
putPieceAt sq ds2 ds3 = case ds2 of { MkTup c k -> case ds3 of { Board wkss bkss -> case c of { Black -> Board wkss (Cons (MkTup k sq) bkss); White -> Board (Cons (MkTup k sq) wkss) bkss } } };
opponent ds2 = case ds2 of { Black -> White; White -> Black };
colourOf ds2 = case ds2 of { MkTup c k -> c };
kindOf ds2 = case ds2 of { MkTup c k -> k };
sameColour ds2 ds3 = case ds2 of { Black -> case ds3 of { Black -> True; White -> False }; White -> case ds3 of { Black -> False; White -> True } };
moveLine bd110 c sq inc1 = let { incsq = inc1 sq } in case onboard incsq of { False -> Nil; True -> case pieceAt bd110 incsq of { Nothing -> Cons (Move incsq Nothing Nothing) (moveLine bd110 c incsq inc1); Just p -> case p of { MkTup c1 k -> case c1 of { Black -> case c of { Black -> Nil; White -> Cons (Move incsq (Just p) Nothing) Nil }; White -> case c of { Black -> Cons (Move incsq (Just p) Nothing) Nil; White -> Nil } } } } };
bishopmoves c sq bd110 = append (moveLine bd110 c sq bishopmovesLiftA0) (append (moveLine bd110 c sq bishopmovesLiftA1) (append (moveLine bd110 c sq bishopmovesLiftA2) (moveLine bd110 c sq bishopmovesLiftA3)));
bishopmovesLiftA0 ds2 = case ds2 of { MkTup x y -> MkTup (dec x) (inc y) };
bishopmovesLiftA1 ds2 = case ds2 of { MkTup x y -> MkTup (inc x) (inc y) };
bishopmovesLiftA2 ds2 = case ds2 of { MkTup x y -> MkTup (dec x) (dec y) };
bishopmovesLiftA3 ds2 = case ds2 of { MkTup x y -> MkTup (inc x) (dec y) };
rookmoves c sq bd110 = append (moveLine bd110 c sq rookmovesLiftA0) (append (moveLine bd110 c sq rookmovesLiftA1) (append (moveLine bd110 c sq rookmovesLiftA2) (moveLine bd110 c sq rookmovesLiftA3)));
rookmovesLiftA0 ds2 = case ds2 of { MkTup x y -> MkTup (dec x) y };
rookmovesLiftA1 ds2 = case ds2 of { MkTup x y -> MkTup (inc x) y };
rookmovesLiftA2 ds2 = case ds2 of { MkTup x y -> MkTup x (dec y) };
rookmovesLiftA3 ds2 = case ds2 of { MkTup x y -> MkTup x (inc y) };
queenmoves c sq bd110 = append (bishopmoves c sq bd110) (rookmoves c sq bd110);
sift c bd110 ms ds2 = case ds2 of { Nil -> ms; Cons sq sqs -> case onboard sq of { False -> sift c bd110 ms sqs; True -> case pieceAt bd110 sq of { Nothing -> sift c bd110 (Cons (Move sq Nothing Nothing) ms) sqs; Just p -> case p of { MkTup c1 k -> let { sj = sift c bd110 (Cons (Move sq (Just p) Nothing) ms) sqs } in case c1 of { Black -> case c of { Black -> sift Black bd110 ms sqs; White -> sj }; White -> case c of { Black -> sj; White -> sift White bd110 ms sqs } } } } } };
kingmoves c ds2 bd110 = case ds2 of { MkTup p q -> let { qd = (-) q 1 } in let { qi = (+) q 1 } in let { pd = (-) p 1 } in let { pi = (+) p 1 } in sift c bd110 Nil (Cons (MkTup pd qi) (Cons (MkTup p qi) (Cons (MkTup pi qi) (Cons (MkTup pd q) (Cons (MkTup pi q) (Cons (MkTup pd qd) (Cons (MkTup p qd) (Cons (MkTup pi qd) Nil)))))))) };
knightmoves c ds2 bd110 = case ds2 of { MkTup p q -> let { qd2 = (-) q 2 } in let { qi2 = (+) q 2 } in let { pd2 = (-) p 2 } in let { pi2 = (+) p 2 } in let { qd = (-) q 1 } in let { qi = (+) q 1 } in let { pd = (-) p 1 } in let { pi = (+) p 1 } in sift c bd110 Nil (Cons (MkTup pd qi2) (Cons (MkTup pi qi2) (Cons (MkTup pd2 qi) (Cons (MkTup pi2 qi) (Cons (MkTup pd2 qd) (Cons (MkTup pi2 qd) (Cons (MkTup pd qd2) (Cons (MkTup pi qd2) Nil)))))))) };
rank ds2 = case ds2 of { MkTup f r -> r };
file ds2 = case ds2 of { MkTup f r -> f };
forcesColoured ds2 ds3 = case ds2 of { Black -> case ds3 of { Board wkss bkss -> bkss }; White -> case ds3 of { Board wkss bkss -> wkss } };
kingSquare c b = kSq (forcesColoured c b);
kingInCheckFrom c bd110 ds2 = case ds2 of { MkTup f ds3 -> case ds3 of { MkTup x y -> case kSq (forcesColoured c bd110) of { MkTup xk yk -> case f of { King -> case (<=) (abs ((-) x xk)) 1 of { False -> False; True -> (<=) (abs ((-) y yk)) 1 }; Queen -> case kingInCheckFrom c bd110 (MkTup Rook (MkTup x y)) of { False -> kingInCheckFrom c bd110 (MkTup Bishop (MkTup x y)); True -> True }; Rook -> let { sj = case (==) y yk of { False -> False; True -> let { e = rankPath yk x xk } in case bd110 of { Board wkss bkss -> emptyAtAllAnd e (emptyAtAllAnd e True bkss) wkss } } } in case (==) x xk of { False -> sj; True -> let { e = filePath xk y yk } in case bd110 of { Board wkss bkss -> case emptyAtAllAnd e (emptyAtAllAnd e True bkss) wkss of { False -> sj; True -> True } } }; Bishop -> let { sj = case (==) ((+) x y) ((+) xk yk) of { False -> False; True -> let { e = kingInCheckFromLiftA0 } in let { e1 = (+) xk yk } in let { e2 = diagPath e e1 x xk } in case bd110 of { Board wkss bkss -> emptyAtAllAnd e2 (emptyAtAllAnd e2 True bkss) wkss } } } in case (==) ((-) x y) ((-) xk yk) of { False -> sj; True -> let { e = kingInCheckFromLiftA1 } in let { e1 = (-) xk yk } in let { e2 = diagPath e e1 x xk } in case bd110 of { Board wkss bkss -> case emptyAtAllAnd e2 (emptyAtAllAnd e2 True bkss) wkss of { False -> sj; True -> True } } }; Knight -> let { sj = case (==) (abs ((-) x xk)) 1 of { False -> False; True -> (==) (abs ((-) y yk)) 2 } } in case (==) (abs ((-) x xk)) 2 of { False -> sj; True -> case (==) (abs ((-) y yk)) 1 of { False -> sj; True -> True } }; Pawn -> case (==) (abs ((-) x xk)) 1 of { False -> False; True -> (==) yk case c of { Black -> inc y; White -> dec y } } } } } };
kingInCheckFromLiftA0 a b = (+) a b;
kingInCheckFromLiftA1 a b = (-) a b;
kingincheck c bd110 = any (kingInCheckFrom c bd110) case c of { Black -> case bd110 of { Board wkss bkss -> wkss }; White -> case bd110 of { Board wkss bkss -> bkss } };
tryMove c bd110 ds2 ds3 = case ds2 of { MkTup k sqFrom -> case ds3 of { Move sqTo mcp mpp -> let { bd111 = case c of { Black -> case bd110 of { Board wkss bkss -> Board wkss (rPa sqFrom bkss) }; White -> case bd110 of { Board wkss bkss -> Board (rPa sqFrom wkss) bkss } } } in let { p = MkTup c k } in let { bd112 = case mcp of { Nothing -> case mpp of { Nothing -> case p of { MkTup c1 k1 -> case bd111 of { Board wkss bkss -> case c1 of { Black -> Board wkss (Cons (MkTup k1 sqTo) bkss); White -> Board (Cons (MkTup k1 sqTo) wkss) bkss } } }; Just x -> case x of { MkTup c1 k1 -> case bd111 of { Board wkss bkss -> case c1 of { Black -> Board wkss (Cons (MkTup k1 sqTo) bkss); White -> Board (Cons (MkTup k1 sqTo) wkss) bkss } } } }; Just x -> let { sj = tryMoveLiftA0 c bd111 sqTo } in case mpp of { Nothing -> case p of { MkTup c1 k1 -> sj c1 k1 }; Just x1 -> case x1 of { MkTup c1 k1 -> sj c1 k1 } } } } in case kingincheck c bd112 of { False -> Cons (MkTup (MoveInFull p sqFrom (Move sqTo mcp mpp)) bd112) Nil; True -> Nil } } };
tryMoveLiftA0 c bd111 sqTo c1 k1 = case c of { Black -> case bd111 of { Board wkss bkss -> case c1 of { Black -> Board (rPa sqTo wkss) (Cons (MkTup k1 sqTo) bkss); White -> Board (Cons (MkTup k1 sqTo) (rPa sqTo wkss)) bkss } }; White -> case bd111 of { Board wkss bkss -> case c1 of { Black -> Board wkss (Cons (MkTup k1 sqTo) (rPa sqTo bkss)); White -> Board (Cons (MkTup k1 sqTo) wkss) (rPa sqTo bkss) } } };
secondRank ds2 r = case ds2 of { Black -> (==) r 7; White -> (==) r 2 };
lastRank ds2 r = case ds2 of { Black -> (==) r 1; White -> (==) r 8 };
promote c sq mcp = case lastRank c case sq of { MkTup f r -> r } of { False -> Cons (Move sq mcp Nothing) Nil; True -> map (Move sq mcp) (Cons (Just (MkTup c Queen)) (Cons (Just (MkTup c Rook)) (Cons (Just (MkTup c Bishop)) (Cons (Just (MkTup c Knight)) Nil)))) };
promoteCap c sq bd110 = case pieceAt bd110 sq of { Nothing -> Nil; Just p -> case p of { MkTup c1 k -> case c1 of { Black -> case c of { Black -> Nil; White -> promote White sq (pieceAt bd110 sq) }; White -> case c of { Black -> promote Black sq (pieceAt bd110 sq); White -> Nil } } } };
pawnmoves c ds2 bd110 = case ds2 of { MkTup p q -> let { fwd = case c of { Black -> (-) 0 1; White -> 1 } } in let { on1 = (+) q fwd } in let { on2 = MkTup p on1 } in let { on3 = (+) ((+) q fwd) fwd } in let { on4 = MkTup p on3 } in append case pieceAt bd110 on2 of { Nothing -> append (promote c on2 Nothing) case secondRank c q of { False -> Nil; True -> case pieceAt bd110 on4 of { Nothing -> Cons (Move on4 Nothing Nothing) Nil; Just ds3 -> Nil } }; Just ds3 -> Nil } (append (promoteCap c (MkTup ((+) p 1) ((+) q fwd)) bd110) (promoteCap c (MkTup ((-) p 1) ((+) q fwd)) bd110)) };
rawmoves c ds2 bd110 = case ds2 of { MkTup k sq -> case k of { King -> kingmoves c sq bd110; Queen -> queenmoves c sq bd110; Rook -> rookmoves c sq bd110; Bishop -> bishopmoves c sq bd110; Knight -> knightmoves c sq bd110; Pawn -> pawnmoves c sq bd110 } };
movesForPiece c bd110 p = concatMap (tryMove c bd110 p) (rawmoves c p bd110);
moveDetailsFor c bd110 = concatMap (movesForPiece c bd110) (forcesColoured c bd110);
ds  = let { solnAnd1 = dsLiftA0 solnOr1; replies1 = dsLiftA1 solnAnd1; solnOr1 = dsLiftA2 replies1 } in MkQuad replies1 solnAnd1 (dsLiftA3 solnOr1) solnOr1;
dsLiftA0 solnOr1 c n ds2 rest = case ds2 of { MkTup mif b -> let { c1 = case c of { Black -> White; White -> Black } } in case foldr (solnOr1 c1 ((-) n 1)) Nothing (moveDetailsFor c1 b) of { Nothing -> Nothing; Just s -> case rest of { Nothing -> Nothing; Just ms -> Just (Cons (MkTup mif s) ms) } } };
dsLiftA1 solnAnd1 bd110 c n = let { mds = concatMap (movesForPiece c bd110) (forcesColoured c bd110) } in case (==) n 0 of { False -> foldr (solnAnd1 c n) (Just Nil) mds; True -> case mds of { Nil -> Just Nil; Cons x xs -> Nothing } };
dsLiftA2 replies1 c n ds2 other = case ds2 of { MkTup mif b -> case replies1 b case c of { Black -> White; White -> Black } ((-) n 1) of { Nothing -> other; Just rs -> case rs of { Nil -> case any (kingInCheckFrom case c of { Black -> White; White -> Black } b) case c of { Black -> case b of { Board wkss bkss -> bkss }; White -> case b of { Board wkss bkss -> wkss } } of { False -> other; True -> Just (Solution mif Nil) }; Cons x xs -> Just (Solution mif rs) } } };
dsLiftA3 solnOr1 bd110 c n = foldr (solnOr1 c n) Nothing (moveDetailsFor c bd110);
replies  = case ds of { MkQuad replies1 solnAnd1 solution1 solnOr1 -> replies1 };
solnAnd  = case ds of { MkQuad replies1 solnAnd1 solution1 solnOr1 -> solnAnd1 };
solution  = case ds of { MkQuad replies1 solnAnd1 solution1 solnOr1 -> solution1 };
solve bd110 c n = showResult case ds of { MkQuad replies1 solnAnd1 solution1 solnOr1 -> solution1 bd110 c ((-) ((+) n n) 1) };
solveProblem ds2 = case ds2 of { MkTup bd110 ds3 -> case ds3 of { MkTup c n -> solve bd110 c n } };
bd  = 7;
bd1  = 8;
bd2  = MkTup bd bd1;
bd3  = MkTup Knight bd2;
bd4  = 5;
bd5  = 7;
bd6  = MkTup bd4 bd5;
bd7  = MkTup Rook bd6;
bd8  = 8;
bd9  = 7;
bd10  = MkTup bd8 bd9;
bd11  = MkTup King bd10;
bd12  = 4;
bd13  = 5;
bd14  = MkTup bd12 bd13;
bd15  = MkTup Bishop bd14;
bd16  = 8;
bd17  = 4;
bd18  = MkTup bd16 bd17;
bd19  = MkTup Pawn bd18;
bd20  = 7;
bd21  = 3;
bd22  = MkTup bd20 bd21;
bd23  = MkTup Pawn bd22;
bd24  = 5;
bd25  = 2;
bd26  = MkTup bd24 bd25;
bd27  = MkTup Pawn bd26;
bd28  = 6;
bd29  = 2;
bd30  = MkTup bd28 bd29;
bd31  = MkTup Pawn bd30;
bd32  = 5;
bd33  = 1;
bd34  = MkTup bd32 bd33;
bd35  = MkTup Queen bd34;
bd36  = Cons bd35 Nil;
bd37  = Cons bd31 bd36;
bd38  = Cons bd27 bd37;
bd39  = Cons bd23 bd38;
bd40  = Cons bd19 bd39;
bd41  = Cons bd15 bd40;
bd42  = Cons bd11 bd41;
bd43  = Cons bd7 bd42;
bd44  = Cons bd3 bd43;
bd45  = 2;
bd46  = 8;
bd47  = MkTup bd45 bd46;
bd48  = MkTup Knight bd47;
bd49  = 7;
bd50  = 7;
bd51  = MkTup bd49 bd50;
bd52  = MkTup Pawn bd51;
bd53  = 4;
bd54  = 6;
bd55  = MkTup bd53 bd54;
bd56  = MkTup Pawn bd55;
bd57  = 3;
bd58  = 5;
bd59  = MkTup bd57 bd58;
bd60  = MkTup Pawn bd59;
bd61  = 6;
bd62  = 5;
bd63  = MkTup bd61 bd62;
bd64  = MkTup King bd63;
bd65  = 8;
bd66  = 5;
bd67  = MkTup bd65 bd66;
bd68  = MkTup Pawn bd67;
bd69  = 4;
bd70  = 4;
bd71  = MkTup bd69 bd70;
bd72  = MkTup Pawn bd71;
bd73  = 2;
bd74  = 3;
bd75  = MkTup bd73 bd74;
bd76  = MkTup Pawn bd75;
bd77  = 5;
bd78  = 3;
bd79  = MkTup bd77 bd78;
bd80  = MkTup Pawn bd79;
bd81  = 7;
bd82  = 2;
bd83  = MkTup bd81 bd82;
bd84  = MkTup Pawn bd83;
bd85  = 1;
bd86  = 1;
bd87  = MkTup bd85 bd86;
bd88  = MkTup Queen bd87;
bd89  = 2;
bd90  = 1;
bd91  = MkTup bd89 bd90;
bd92  = MkTup Knight bd91;
bd93  = 8;
bd94  = 1;
bd95  = MkTup bd93 bd94;
bd96  = MkTup Bishop bd95;
bd97  = Cons bd96 Nil;
bd98  = Cons bd92 bd97;
bd99  = Cons bd88 bd98;
bd100  = Cons bd84 bd99;
bd101  = Cons bd80 bd100;
bd102  = Cons bd76 bd101;
bd103  = Cons bd72 bd102;
bd104  = Cons bd68 bd103;
bd105  = Cons bd64 bd104;
bd106  = Cons bd60 bd105;
bd107  = Cons bd56 bd106;
bd108  = Cons bd52 bd107;
bd109  = Cons bd48 bd108;
ds1  = 3;
main  = solve (Board bd44 bd109) White ds1;
solnOr  = case ds of { MkQuad replies1 solnAnd1 solution1 solnOr1 -> solnOr1 };
skrep  = KindRepTyConApp Nil;
skrep1  = Cons Nil;
skrep2  = Cons;
skrep3  = KindRepTyConApp;
skrep4  = KindRepVar 0;
skrep5  = Cons Nil;
skrep6  = KindRepTyConApp;
skrep7  = KindRepFun;
skrep8  = KindRepTyConApp Nil;
skrep9  = Cons Nil;
skrep10  = Cons;
skrep11  = KindRepTyConApp;
skrep12  = Cons Nil;
skrep13  = KindRepTyConApp;
skrep14  = KindRepTyConApp Nil;
skrep15  = Cons Nil;
skrep16  = Cons;
skrep17  = KindRepTyConApp;
skrep18  = Cons Nil;
skrep19  = KindRepTyConApp;
skrep20  = KindRepTyConApp Nil;
skrep21  = KindRepFun;
skrep22  = KindRepFun;
skrep23  = KindRepTyConApp Nil;
skrep24  = KindRepFun;
skrep25  = KindRepFun;
skrep26  = KindRepFun;
skrep27  = KindRepTyConApp Nil;
skrep28  = KindRepFun;
skrep29  = KindRepFun;
skrep30  = KindRepFun;
skrep31  = KindRepTyConApp Nil;
skrep32  = Cons Nil;
skrep33  = Cons;
skrep34  = KindRepTyConApp;
skrep35  = Cons Nil;
skrep36  = KindRepTyConApp;
skrep37  = KindRepFun;
skrep38  = KindRepFun;
}
