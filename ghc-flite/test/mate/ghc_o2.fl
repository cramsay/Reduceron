{
main36  = 6;
main1  = 3;
main31  = 4;
main40  = MkTup main31 main36;
main39  = MkTup Pawn main40;
main30  = MkTup main31 main31;
main29  = MkTup Pawn main30;
main26  = 5;
main65  = MkTup main31 main26;
main64  = MkTup Bishop main65;
main38  = MkTup main1 main26;
main37  = MkTup Pawn main38;
main35  = MkTup main36 main26;
main34  = MkTup King main35;
main25  = MkTup main26 main1;
main24  = MkTup Pawn main25;
main73  = Just Nil;
lvl  = (-) 0 1;
main23  = 7;
main69  = MkTup main26 main23;
main68  = MkTup Rook main69;
main61  = MkTup main23 main1;
main60  = MkTup Pawn main61;
main42  = MkTup main23 main23;
main41  = MkTup Pawn main42;
knightmoves1  = 2;
secondRank ds r = case ds of { Black -> (==) r 7; White -> (==) r 2 };
main59  = MkTup main26 knightmoves1;
main58  = MkTup Pawn main59;
main57  = MkTup main36 knightmoves1;
main56  = MkTup Pawn main57;
main28  = MkTup knightmoves1 main1;
main27  = MkTup Pawn main28;
main22  = MkTup main23 knightmoves1;
main21  = MkTup Pawn main22;
moveLine1  = 8;
main71  = MkTup main23 moveLine1;
main70  = MkTup Knight main71;
main67  = MkTup moveLine1 main23;
main66  = MkTup King main67;
main63  = MkTup moveLine1 main31;
main62  = MkTup Pawn main63;
main44  = MkTup knightmoves1 moveLine1;
main43  = MkTup Knight main44;
main33  = MkTup moveLine1 main26;
main32  = MkTup Pawn main33;
skrep  = KindRepVar 0;
skrep1  = Cons Nil;
skrep2  = KindRepTyConApp Nil;
skrep3  = Cons Nil;
skrep4  = Cons;
skrep5  = KindRepTyConApp;
skrep6  = Cons Nil;
skrep7  = Cons;
skrep8  = KindRepTyConApp;
skrep9  = Cons Nil;
skrep10  = KindRepTyConApp;
skrep11  = Cons Nil;
skrep12  = Cons;
skrep13  = KindRepTyConApp;
skrep14  = Cons Nil;
skrep15  = KindRepTyConApp;
skrep16  = KindRepTyConApp Nil;
skrep17  = KindRepFun;
skrep18  = KindRepTyConApp Nil;
skrep19  = KindRepFun;
skrep20  = KindRepFun;
skrep21  = KindRepTyConApp Nil;
skrep22  = KindRepFun;
skrep23  = KindRepFun;
skrep24  = KindRepTyConApp Nil;
skrep25  = Cons Nil;
skrep26  = Cons;
skrep27  = KindRepTyConApp;
skrep28  = Cons Nil;
skrep29  = KindRepTyConApp;
skrep30  = KindRepFun;
forcesColoured ds ds1 = case ds of { Black -> case ds1 of { Board wkss bkss -> bkss }; White -> case ds1 of { Board wkss bkss -> wkss } };
sameColour ds ds1 = case ds of { Black -> case ds1 of { Black -> True; White -> False }; White -> case ds1 of { Black -> False; White -> True } };
opponent ds = case ds of { Black -> White; White -> Black };
putPieceAt sq ds ds1 = case ds of { MkTup c k -> case ds1 of { Board wkss bkss -> case c of { Black -> Board wkss (Cons (MkTup k sq) bkss); White -> Board (Cons (MkTup k sq) wkss) bkss } } };
emptyAtAllAnd e b ds = case ds of { Nil -> b; Cons ds1 xs -> case ds1 of { MkTup k s -> case e s of { False -> emptyAtAllAnd e b xs; True -> False } } };
emptyAtAll ds e = case ds of { Board wkss bkss -> emptyAtAllAnd e (emptyAtAllAnd e True bkss) wkss };
isKing k = case k of { King -> True; Queen -> False; Rook -> False; Bishop -> False; Knight -> False; Pawn -> False };
kindToChar1  = 'P';
kindToChar2  = 'N';
kindToChar3  = 'B';
kindToChar4  = 'R';
kindToChar5  = 'Q';
kindToChar6  = 'K';
kindToChar ds = case ds of { King -> kindToChar6; Queen -> kindToChar5; Rook -> kindToChar4; Bishop -> kindToChar3; Knight -> kindToChar2; Pawn -> kindToChar1 };
sumAcc eta eta1 = let { sumAcc2 = sumAccLiftA0 } in sumAcc2 eta eta1;
sumAccLiftA0 acc ds = case ds of { Nil -> acc; Cons x xs -> sumAccLiftA0 ((+) acc x) xs };
foldr f z ds = case ds of { Nil -> z; Cons x xs -> f x (foldr f z xs) };
mapussmap sc sc1 sc2 = Cons (sc2 sc) (map sc2 sc1);
map f ds = case ds of { Nil -> Nil; Cons x xs -> Cons (f x) (map f xs) };
abs1  = 0;
sum xs = let { sumAcc2 = sumLiftA0 } in sumAcc2 abs1 xs;
sumLiftA0 acc ds = case ds of { Nil -> acc; Cons x xs1 -> sumLiftA0 ((+) acc x) xs1 };
kSq eta = let { lvl4 = MkTup abs1 abs1 } in let { kSq1 = kSqLiftA0 lvl4 } in kSq1 eta;
kSqLiftA0 lvl4 ds = case ds of { Nil -> lvl4; Cons ds1 kss -> case ds1 of { MkTup k s -> case k of { King -> s; Queen -> kSqLiftA0 kss; Rook -> kSqLiftA0 kss; Bishop -> kSqLiftA0 kss; Knight -> kSqLiftA0 kss; Pawn -> kSqLiftA0 kss } } };
lvl1  = MkTup abs1 abs1;
kingSquareukSq ds = case ds of { Nil -> lvl1; Cons ds1 kss -> case ds1 of { MkTup k s -> case k of { King -> s; Queen -> kingSquareukSq kss; Rook -> kingSquareukSq kss; Bishop -> kingSquareukSq kss; Knight -> kingSquareukSq kss; Pawn -> kingSquareukSq kss } } };
swkingSquare w ww ww1 = case w of { Black -> kingSquareukSq ww1; White -> kingSquareukSq ww };
kingSquare w w1 = case w1 of { Board ww1 ww2 -> swkingSquare w ww1 ww2 };
abs n = case (<=) n abs1 of { False -> n; True -> (-) abs1 n };
append ds ys = case ds of { Nil -> ys; Cons x xs -> Cons x (append xs ys) };
concatMap f ds = case ds of { Nil -> Nil; Cons x xs -> append (f x) (concatMap f xs) };
null ds = case ds of { Nil -> True; Cons x xs -> False };
cross ds ds1 = case ds of { MkTup f g -> case ds1 of { MkTup x y -> MkTup (f x) (g y) } };
swunzip w = case w of { Nil -> MkTup Nil Nil; Cons ds xs -> case ds of { MkTup a2 b -> let { u = case swunzip xs of { MkTup ww1 ww2 -> MkTup ww1 ww2 } } in MkTup (Cons a2 case u of { MkTup x y -> x }) (Cons b case u of { MkTup x y -> y }) } };
unzip w = case swunzip w of { MkTup ww1 ww2 -> MkTup ww1 ww2 };
snd ds = case ds of { MkTup x y -> y };
kindOf  = snd;
rank  = snd;
fst ds = case ds of { MkTup x y -> x };
colourOf  = fst;
file  = fst;
any p ds = case ds of { Nil -> False; Cons x xs -> case p x of { False -> any p xs; True -> True } };
dis ds q = case ds of { False -> q; True -> True };
mainusspolyurPa sc sc1 sc2 = case sc of { Nil -> Nil; Cons ks kss -> case ks of { MkTup k s -> case s of { MkTup f1 r1 -> case (==) f1 sc1 of { False -> Cons ks (mainusspolyurPa kss sc1 sc2); True -> case (==) r1 sc2 of { False -> Cons ks (mainusspolyurPa kss sc1 sc2); True -> kss } } } } };
main72 sq ds = case ds of { Nil -> Nil; Cons ks kss -> case ks of { MkTup k s -> case s of { MkTup f1 r1 -> case sq of { MkTup f2 r2 -> case (==) f1 f2 of { False -> Cons ks (mainusspolyurPa kss f2 r2); True -> case (==) r1 r2 of { False -> Cons ks (mainusspolyurPa kss f2 r2); True -> kss } } } } } };
rPa eta eta1 = let { ssrPa = rPaLiftA0 } in case eta1 of { Nil -> Nil; Cons ks kss -> case ks of { MkTup k s -> case s of { MkTup f1 r1 -> case eta of { MkTup f2 r2 -> case (==) f1 f2 of { False -> Cons ks (ssrPa kss f2 r2); True -> case (==) r1 r2 of { False -> Cons ks (ssrPa kss f2 r2); True -> kss } } } } } };
rPaLiftA0 sc sc1 sc2 = case sc of { Nil -> Nil; Cons ks kss -> case ks of { MkTup k s -> case s of { MkTup f1 r1 -> case (==) f1 sc1 of { False -> Cons ks (rPaLiftA0 kss sc1 sc2); True -> case (==) r1 sc2 of { False -> Cons ks (rPaLiftA0 kss sc1 sc2); True -> kss } } } } };
rmPieceAt w w1 w2 = case w2 of { Board ww1 ww2 -> case w of { Black -> Board ww1 (main72 w1 ww2); White -> Board (main72 w1 ww1) ww2 } };
moveLineusspieceAtWith sc sc1 sc2 sc3 sc4 = case sc of { Nil -> sc1; Cons ds xs -> case ds of { MkTup k s -> case s of { MkTup f1 r1 -> case (==) f1 sc3 of { False -> moveLineusspieceAtWith xs sc1 sc2 sc3 sc4; True -> case (==) r1 sc4 of { False -> moveLineusspieceAtWith xs sc1 sc2 sc3 sc4; True -> Just (MkTup sc2 k) } } } } };
pieceAtupieceAtWith sq c n ds = case ds of { Nil -> n; Cons ds1 xs -> case ds1 of { MkTup k s -> case s of { MkTup f1 r1 -> case sq of { MkTup f2 r2 -> case (==) f1 f2 of { False -> moveLineusspieceAtWith xs n c f2 r2; True -> case (==) r1 r2 of { False -> moveLineusspieceAtWith xs n c f2 r2; True -> Just (MkTup c k) } } } } } };
swpieceAt ww ww1 w = pieceAtupieceAtWith w White (pieceAtupieceAtWith w Black Nothing ww1) ww;
pieceAt w w1 = case w of { Board ww1 ww2 -> swpieceAt ww1 ww2 w1 };
pieceAtWith eta eta1 eta2 eta3 = let { sspieceAtWith = pieceAtWithLiftA0 } in case eta3 of { Nil -> eta2; Cons ds xs -> case ds of { MkTup k s -> case s of { MkTup f1 r1 -> case eta of { MkTup f2 r2 -> case (==) f1 f2 of { False -> sspieceAtWith xs eta2 eta1 f2 r2; True -> case (==) r1 r2 of { False -> sspieceAtWith xs eta2 eta1 f2 r2; True -> Just (MkTup eta1 k) } } } } } };
pieceAtWithLiftA0 sc sc1 sc2 sc3 sc4 = case sc of { Nil -> sc1; Cons ds xs -> case ds of { MkTup k s -> case s of { MkTup f1 r1 -> case (==) f1 sc3 of { False -> pieceAtWithLiftA0 xs sc1 sc2 sc3 sc4; True -> case (==) r1 sc4 of { False -> pieceAtWithLiftA0 xs sc1 sc2 sc3 sc4; True -> Just (MkTup sc2 k) } } } } };
swsameSquare ww w ww1 ww2 ww3 ww4 = case ww ww1 ww3 of { False -> False; True -> (==) w ww2 ww4 };
sameSquare w w1 w2 w3 = case w of { CEq ww1 ww2 -> case w2 of { MkTup ww4 ww5 -> case w3 of { MkTup ww7 ww8 -> swsameSquare ww1 w1 ww4 ww5 ww7 ww8 } } };
con ds q = case ds of { False -> False; True -> q };
or ds ds1 = case ds of { False -> ds1; True -> True };
and ds ds1 = case ds of { False -> False; True -> ds1 };
not ds = case ds of { False -> True; True -> False };
maybe n j ds = case ds of { Nothing -> n; Just x -> j x };
no ds = case ds of { Nothing -> True; Just ds1 -> False };
minus a1 b = (-) a1 b;
plus a1 b = (+) a1 b;
max x y = case (<=) x y of { False -> x; True -> y };
min x y = case (<=) x y of { False -> y; True -> x };
bishopmoves2  = 1;
inc n = (+) n bishopmoves2;
dec n = (-) n bishopmoves2;
onFor ds eta = case ds of { Black -> inc eta; White -> dec eta };
elemAt eta eta1 = let { lvl4 = bishopmoves2 } in let { lvl5 = abs1 } in let { lvl6 = abs1 } in let { elemAt1 = elemAtLiftA0 lvl6 lvl5 lvl4 } in elemAt1 eta eta1;
elemAtLiftA0 lvl6 lvl5 lvl4 ds n = case ds of { Nil -> lvl6; Cons x xs -> case (==) n lvl5 of { False -> elemAtLiftA0 xs ((-) n lvl4); True -> x } };
swonboard ww ww1 = case (<=) bishopmoves2 ww of { False -> False; True -> case (<=) ww moveLine1 of { False -> False; True -> case (<=) bishopmoves2 ww1 of { False -> False; True -> (<=) ww1 moveLine1 } } };
onboard w = case w of { MkTup ww1 ww2 -> swonboard ww1 ww2 };
siftusssift sc sc1 sc2 sc3 = case sc of { Nil -> sc1; Cons sq sqs -> case sq of { MkTup ww1 ww2 -> case swonboard ww1 ww2 of { False -> siftusssift sqs sc1 sc2 sc3; True -> case moveLineusspieceAtWith sc2 (moveLineusspieceAtWith sc3 Nothing Black ww1 ww2) White ww1 ww2 of { Nothing -> siftusssift sqs (Cons (Move sq Nothing Nothing) sc1) sc2 sc3; Just p -> case p of { MkTup c k -> case c of { Black -> siftusssift sqs (Cons (Move sq (moveLineusspieceAtWith sc2 (moveLineusspieceAtWith sc3 Nothing Black ww1 ww2) White ww1 ww2) Nothing) sc1) sc2 sc3; White -> siftusssift sqs sc1 sc2 sc3 } } } } } };
siftusssift1 sc sc1 sc2 sc3 = case sc of { Nil -> sc1; Cons sq sqs -> case sq of { MkTup ww1 ww2 -> case swonboard ww1 ww2 of { False -> siftusssift1 sqs sc1 sc2 sc3; True -> case moveLineusspieceAtWith sc2 (moveLineusspieceAtWith sc3 Nothing Black ww1 ww2) White ww1 ww2 of { Nothing -> siftusssift1 sqs (Cons (Move sq Nothing Nothing) sc1) sc2 sc3; Just p -> case p of { MkTup c k -> case c of { Black -> siftusssift1 sqs sc1 sc2 sc3; White -> siftusssift1 sqs (Cons (Move sq (moveLineusspieceAtWith sc2 (moveLineusspieceAtWith sc3 Nothing Black ww1 ww2) White ww1 ww2) Nothing) sc1) sc2 sc3 } } } } } };
siftusssift2 sc sc1 sc2 sc3 sc4 = case sc of { Nil -> sc1; Cons sq sqs -> case sq of { MkTup ww1 ww2 -> case swonboard ww1 ww2 of { False -> siftusssift2 sqs sc1 sc2 sc3 sc4; True -> case moveLineusspieceAtWith sc2 (moveLineusspieceAtWith sc3 Nothing Black ww1 ww2) White ww1 ww2 of { Nothing -> siftusssift2 sqs (Cons (Move sq Nothing Nothing) sc1) sc2 sc3 sc4; Just p -> case p of { MkTup c k -> let { sj = siftusssift2 sqs (Cons (Move sq (moveLineusspieceAtWith sc2 (moveLineusspieceAtWith sc3 Nothing Black ww1 ww2) White ww1 ww2) Nothing) sc1) sc2 sc3 sc4 } in case c of { Black -> case sc4 of { Black -> siftusssift1 sqs sc1 sc2 sc3; White -> sj }; White -> case sc4 of { Black -> sj; White -> siftusssift sqs sc1 sc2 sc3 } } } } } } };
sift c bd ms ds = case ds of { Nil -> ms; Cons sq sqs -> case sq of { MkTup ww1 ww2 -> case swonboard ww1 ww2 of { False -> sift c bd ms sqs; True -> case bd of { Board ww4 ww5 -> case moveLineusspieceAtWith ww4 (moveLineusspieceAtWith ww5 Nothing Black ww1 ww2) White ww1 ww2 of { Nothing -> siftusssift2 sqs (Cons (Move sq Nothing Nothing) ms) ww4 ww5 c; Just p -> case p of { MkTup c1 k -> let { sj = siftusssift2 sqs (Cons (Move sq (moveLineusspieceAtWith ww4 (moveLineusspieceAtWith ww5 Nothing Black ww1 ww2) White ww1 ww2) Nothing) ms) ww4 ww5 c } in case c1 of { Black -> case c of { Black -> siftusssift1 sqs ms ww4 ww5; White -> sj }; White -> case c of { Black -> sj; White -> siftusssift sqs ms ww4 ww5 } } } } } } } };
bishopmoves5 ds = case ds of { MkTup x y -> MkTup ((-) x bishopmoves2) ((+) y bishopmoves2) };
bishopmoves4 ds = case ds of { MkTup x y -> MkTup ((+) x bishopmoves2) ((+) y bishopmoves2) };
bishopmoves3 ds = case ds of { MkTup x y -> MkTup ((-) x bishopmoves2) ((-) y bishopmoves2) };
bishopmoves1 ds = case ds of { MkTup x y -> MkTup ((+) x bishopmoves2) ((-) y bishopmoves2) };
moveLineussmoveLine2 sc sc1 sc2 sc3 sc4 = case sc sc1 of { MkTup ww1 ww2 -> case swonboard ww1 ww2 of { False -> Nil; True -> case moveLineusspieceAtWith sc3 (moveLineusspieceAtWith sc4 Nothing Black ww1 ww2) White ww1 ww2 of { Nothing -> Cons (Move (sc sc1) Nothing Nothing) (moveLineussmoveLine2 sc (sc sc1) sc2 sc3 sc4); Just p -> case p of { MkTup c k -> case c of { Black -> case sc2 of { Black -> Nil; White -> Cons (Move (sc sc1) (moveLineusspieceAtWith sc3 (moveLineusspieceAtWith sc4 Nothing Black ww1 ww2) White ww1 ww2) Nothing) Nil }; White -> case sc2 of { Black -> Cons (Move (sc sc1) (moveLineusspieceAtWith sc3 (moveLineusspieceAtWith sc4 Nothing Black ww1 ww2) White ww1 ww2) Nothing) Nil; White -> Nil } } } } } };
moveLineussmoveLine sc sc1 sc2 = case sc of { MkTup x y -> let { ww = (+) x bishopmoves2 } in let { ww1 = MkTup ww y } in case swonboard ww y of { False -> Nil; True -> case sc2 of { Board ww3 ww4 -> case moveLineusspieceAtWith ww3 (moveLineusspieceAtWith ww4 Nothing Black ww y) White ww y of { Nothing -> Cons (Move ww1 Nothing Nothing) (moveLineussmoveLine ww1 sc1 sc2); Just p -> case p of { MkTup c k -> case c of { Black -> case sc1 of { Black -> Nil; White -> Cons (Move ww1 (moveLineusspieceAtWith ww3 (moveLineusspieceAtWith ww4 Nothing Black ww y) White ww y) Nothing) Nil }; White -> case sc1 of { Black -> Cons (Move ww1 (moveLineusspieceAtWith ww3 (moveLineusspieceAtWith ww4 Nothing Black ww y) White ww y) Nothing) Nil; White -> Nil } } } } } } };
moveLineussmoveLine1 sc sc1 sc2 = case sc of { MkTup x y -> let { ww = (-) x bishopmoves2 } in let { ww1 = MkTup ww y } in case swonboard ww y of { False -> Nil; True -> case sc2 of { Board ww3 ww4 -> case moveLineusspieceAtWith ww3 (moveLineusspieceAtWith ww4 Nothing Black ww y) White ww y of { Nothing -> Cons (Move ww1 Nothing Nothing) (moveLineussmoveLine1 ww1 sc1 sc2); Just p -> case p of { MkTup c k -> case c of { Black -> case sc1 of { Black -> Nil; White -> Cons (Move ww1 (moveLineusspieceAtWith ww3 (moveLineusspieceAtWith ww4 Nothing Black ww y) White ww y) Nothing) Nil }; White -> case sc1 of { Black -> Cons (Move ww1 (moveLineusspieceAtWith ww3 (moveLineusspieceAtWith ww4 Nothing Black ww y) White ww y) Nothing) Nil; White -> Nil } } } } } } };
moveLine bd c sq inc1 = case inc1 sq of { MkTup ww1 ww2 -> case swonboard ww1 ww2 of { False -> Nil; True -> case bd of { Board ww4 ww5 -> case moveLineusspieceAtWith ww4 (moveLineusspieceAtWith ww5 Nothing Black ww1 ww2) White ww1 ww2 of { Nothing -> Cons (Move (inc1 sq) Nothing Nothing) (moveLineussmoveLine2 inc1 (inc1 sq) c ww4 ww5); Just p -> case p of { MkTup c1 k -> case c1 of { Black -> case c of { Black -> Nil; White -> Cons (Move (inc1 sq) (moveLineusspieceAtWith ww4 (moveLineusspieceAtWith ww5 Nothing Black ww1 ww2) White ww1 ww2) Nothing) Nil }; White -> case c of { Black -> Cons (Move (inc1 sq) (moveLineusspieceAtWith ww4 (moveLineusspieceAtWith ww5 Nothing Black ww1 ww2) White ww1 ww2) Nothing) Nil; White -> Nil } } } } } } };
bishopmoves c sq bd = append (moveLine bd c sq bishopmoves5) (append (moveLine bd c sq bishopmoves4) (append (moveLine bd c sq bishopmoves3) (moveLine bd c sq bishopmoves1)));
rookmoves2 ds = case ds of { MkTup x y -> MkTup x ((-) y bishopmoves2) };
rookmoves1 ds = case ds of { MkTup x y -> MkTup x ((+) y bishopmoves2) };
rookmoves c sq bd = append (moveLineussmoveLine1 sq c bd) (append (moveLineussmoveLine sq c bd) (append (moveLine bd c sq rookmoves2) (moveLine bd c sq rookmoves1)));
queenmoves c sq bd = append (bishopmoves c sq bd) (rookmoves c sq bd);
swkingmoves w ww ww1 w1 = let { qd = (-) ww1 bishopmoves2 } in let { qi = (+) ww1 bishopmoves2 } in let { pd = (-) ww bishopmoves2 } in let { pi = (+) ww bishopmoves2 } in sift w w1 Nil (Cons (MkTup pd qi) (Cons (MkTup ww qi) (Cons (MkTup pi qi) (Cons (MkTup pd ww1) (Cons (MkTup pi ww1) (Cons (MkTup pd qd) (Cons (MkTup ww qd) (Cons (MkTup pi qd) Nil))))))));
kingmoves w w1 w2 = case w1 of { MkTup ww1 ww2 -> swkingmoves w ww1 ww2 w2 };
swknightmoves w ww ww1 w1 = let { qd2 = (-) ww1 knightmoves1 } in let { qi2 = (+) ww1 knightmoves1 } in let { pd2 = (-) ww knightmoves1 } in let { pi2 = (+) ww knightmoves1 } in let { qd = (-) ww1 bishopmoves2 } in let { qi = (+) ww1 bishopmoves2 } in let { pd = (-) ww bishopmoves2 } in let { pi = (+) ww bishopmoves2 } in sift w w1 Nil (Cons (MkTup pd qi2) (Cons (MkTup pi qi2) (Cons (MkTup pd2 qi) (Cons (MkTup pi2 qi) (Cons (MkTup pd2 qd) (Cons (MkTup pi2 qd) (Cons (MkTup pd qd2) (Cons (MkTup pi qd2) Nil))))))));
knightmoves w w1 w2 = case w1 of { MkTup ww1 ww2 -> swknightmoves w ww1 ww2 w2 };
sumAcc1 acc ds = case ds of { Nil -> (+) bishopmoves2 acc; Cons x xs -> sumAcc1 ((+) acc x) xs };
size w = case w of { Solution ww1 ww2 -> swsize ww2 };
swsize ww = case swunzip ww of { MkTup ww2 ww3 -> sumAcc1 abs1 (map size ww3) };
showResult ds = case ds of { Nothing -> abs1; Just s -> size s };
lastRank ds r = case ds of { Black -> (==) r bishopmoves2; White -> (==) r moveLine1 };
swpromote w ww ww1 w1 = let { sq = MkTup ww ww1 } in let { sj = mapussmap (Just (MkTup w Queen)) (Cons (Just (MkTup w Rook)) (Cons (Just (MkTup w Bishop)) (Cons (Just (MkTup w Knight)) Nil))) (Move sq w1) } in case w of { Black -> case (==) ww1 bishopmoves2 of { False -> Cons (Move sq w1 Nothing) Nil; True -> sj }; White -> case (==) ww1 moveLine1 of { False -> Cons (Move sq w1 Nothing) Nil; True -> sj } };
promote w w1 w2 = case w1 of { MkTup ww1 ww2 -> swpromote w ww1 ww2 w2 };
swpromoteCap w w1 ww ww1 = case pieceAtupieceAtWith w1 White (pieceAtupieceAtWith w1 Black Nothing ww1) ww of { Nothing -> Nil; Just p -> case p of { MkTup c k -> case c of { Black -> case w of { Black -> Nil; White -> case w1 of { MkTup ww3 ww4 -> swpromote White ww3 ww4 (pieceAtupieceAtWith w1 White (pieceAtupieceAtWith w1 Black Nothing ww1) ww) } }; White -> case w of { Black -> case w1 of { MkTup ww3 ww4 -> swpromote Black ww3 ww4 (pieceAtupieceAtWith w1 White (pieceAtupieceAtWith w1 Black Nothing ww1) ww) }; White -> Nil } } } };
promoteCap w w1 w2 = case w2 of { Board ww1 ww2 -> swpromoteCap w w1 ww1 ww2 };
swpawnmoves w ww ww1 ww2 ww3 = let { fwd = case w of { Black -> lvl; White -> bishopmoves2 } } in let { on1 = (+) ww1 fwd } in let { karg = append (swpromoteCap w (MkTup ((+) ww bishopmoves2) on1) ww2 ww3) (swpromoteCap w (MkTup ((-) ww bishopmoves2) on1) ww2 ww3) } in case moveLineusspieceAtWith ww2 (moveLineusspieceAtWith ww3 Nothing Black ww on1) White ww on1 of { Nothing -> append (append (swpromote w ww on1 Nothing) case secondRank w ww1 of { False -> Nil; True -> let { on2 = (+) on1 fwd } in case moveLineusspieceAtWith ww2 (moveLineusspieceAtWith ww3 Nothing Black ww on2) White ww on2 of { Nothing -> Cons (Move (MkTup ww on2) Nothing Nothing) Nil; Just ds -> Nil } }) karg; Just ds -> karg };
pawnmoves w w1 w2 = case w1 of { MkTup ww1 ww2 -> case w2 of { Board ww4 ww5 -> swpawnmoves w ww1 ww2 ww4 ww5 } };
swrawmoves w ww ww1 w1 = case ww of { King -> kingmoves w ww1 w1; Queen -> queenmoves w ww1 w1; Rook -> rookmoves w ww1 w1; Bishop -> bishopmoves w ww1 w1; Knight -> knightmoves w ww1 w1; Pawn -> pawnmoves w ww1 w1 };
rawmoves w w1 w2 = case w1 of { MkTup ww1 ww2 -> swrawmoves w ww1 ww2 w2 };
swfilePath w w1 w2 ww ww1 = case (==) ww w of {
        False -> False;
        True -> let { wild1 = (<=) w1 w2 ;
                      sj = swfilePathLiftA0 ww1 w1 w2 wild1 } in
                case wild1 of {
                    False -> sj (((+) w2 bishopmoves2) <= ww1) ;
                    True -> sj (((+) w1 bishopmoves2) <= ww1) } } ;
swfilePathLiftA0 ww1 w1 w2 wild1 wild2 = case wild2 of { False -> False; True ->
                case wild1 of {
                    False -> (<=) ww1 ((-) w1 bishopmoves2);
                    True -> (<=) ww1 ((-) w2 bishopmoves2) } };
filePath w w1 w2 w3 = case w3 of { MkTup ww1 ww2 -> swfilePath w w1 w2 ww1 ww2 };

    swrankPath w w1 w2 ww ww1 = case (==) ww1 w of { False -> False;
                                                     True -> let { wild1 = (<=) w1 w2 ; sj = swrankPathLiftA0 ww w1 w2 wild1 } in case wild1 of { False -> sj ( (<=) ((+) w2 bishopmoves2) ww); True -> sj ( (<=) ((+) w1 bishopmoves2) ww) } };
swrankPathLiftA0 ww w1 w2 wild1 wild2 = case wild2 of { False -> False; True -> case wild1 of { False -> ((<=) ww ((-) w1 bishopmoves2)); True -> ((<=) ww ((-) w2 bishopmoves2)) } };
rankPath w w1 w2 w3 = case w3 of { MkTup ww1 ww2 -> swrankPath w w1 w2 ww1 ww2 };

    swdiagPath w w1 w2 w3 ww ww1 = case (==) (w ww ww1) w1 of { False -> False; True -> let { wild1 = (<=) w2 w3 ; sj = swdiagPathLiftA0 ww w2 w3 wild1 } in case wild1 of { False -> sj ((<=) ((+) w3 bishopmoves2) ww); True -> sj ((<=) ((+) w2 bishopmoves2) ww) } };
    swdiagPathLiftA0 ww w2 w3 wild1 wild2 = case wild2 of { False -> False; True -> case wild1 of { False -> (<=) ww ((-) w2 bishopmoves2) ; True -> (<=) ww ((-) w3 bishopmoves2) } };
diagPath w w1 w2 w3 w4 = case w4 of { MkTup ww1 ww2 -> swdiagPath w w1 w2 w3 ww1 ww2 };

    swkingInCheckFrom w ww ww1 ww2 ww3 ww4 = let { sj = swkingInCheckFromLiftA0 ww2 ww4 ww3 w ww ww1 }
        in case w of { Black -> case kingSquareukSq ww1 of { MkTup xk yk -> sj xk yk };
                       White -> case kingSquareukSq ww of { MkTup xk yk -> sj xk yk } };

swkingInCheckFromLiftA1 ww4 yk wild1 = case wild1 of { False -> False; True -> let { n1 = (-) ww4 yk } in case (<=) n1 abs1 of { False -> ((<=) n1 bishopmoves2); True -> (<=) ((-) abs1 n1) bishopmoves2 } };
swkingInCheckFromLiftA2 e ww3 xk w1 = case w1 of { MkTup ww6 ww7 -> swdiagPath plus e ww3 xk ww6 ww7 };
swkingInCheckFromLiftA3 e ww3 xk w1 = case w1 of { MkTup ww6 ww7 -> swdiagPath minus e ww3 xk ww6 ww7 };
    swkingInCheckFromLiftA5 ww4 yk wild2 = case wild2 of { False -> False; True -> let { n1 = (-) ww4 yk } in case (<=) n1 abs1 of { False -> ((==) n1 knightmoves1); True -> ((==) ((-) abs1 n1) knightmoves1) } };
    swkingInCheckFromLiftA4 ww4 yk n wild1 =
        let { sj2 = let { sj3 = swkingInCheckFromLiftA5 ww4 yk } in
              case (<=) n abs1 of { False -> sj3 ((==) n bishopmoves2); True -> sj3 ((==) ((-) abs1 n) bishopmoves2) } } in
    case wild1 of { False -> sj2;
                    True -> let { n1 = (-) ww4 yk } in
                    case (<=) n1 abs1 of { False -> case (==) n1 bishopmoves2 of { False -> sj2; True -> True };
                                           True -> case (==) ((-) abs1 n1) bishopmoves2 of { False -> sj2; True -> True } } };
    swkingInCheckFromLiftA6 w ww4 yk wild1 = case wild1 of { False -> False; True -> case w of { Black -> (==) yk ((+) ww4 bishopmoves2); White -> (==) yk ((-) ww4 bishopmoves2) } };
    swkingInCheckFromLiftA0 ww2 ww4 ww3 w ww ww1 xk yk =
        case ww2 of { King -> let { n = (-) ww3 xk } in
                              let { sj1 = swkingInCheckFromLiftA1 ww4 yk } in
                      case (<=) n abs1 of { False -> sj1 ((<=) n bishopmoves2); True -> sj1 ((<=) ((-) abs1 n) bishopmoves2) };
                      Queen -> case swkingInCheckFrom w ww ww1 Rook ww3 ww4 of {
                          False -> swkingInCheckFrom w ww ww1 Bishop ww3 ww4;
                          True -> True };
                      Rook -> let { wild1 = (==) ww3 xk ; sj1 = case (==) ww4 yk of { False -> False; True -> let { e = rankPath yk ww3 xk } in
                                                                emptyAtAllAnd e (emptyAtAllAnd e True ww1) ww } } in
                              case wild1 of { False -> sj1;
                                              True -> let { e = filePath xk ww4 yk } in
                                              case emptyAtAllAnd e (emptyAtAllAnd e True ww1) ww of { False -> sj1; True -> True } };
                      Bishop -> let { wild1 = (==) ((-) ww3 ww4) ((-) xk yk) ;
                                      sj1 = case (==) ((+) ww3 ww4) ((+) xk yk) of { False -> False;
                                                                                     True -> let { e = (+) xk yk } in
                                                                                     let { e1 = swkingInCheckFromLiftA2 e ww3 xk } in
                                                                                     emptyAtAllAnd e1 (emptyAtAllAnd e1 True ww1) ww } } in
                                case wild1 of { False -> sj1; True -> let { e = (-) xk yk } in let { e1 = swkingInCheckFromLiftA3 e ww3 xk } in
                                                case emptyAtAllAnd e1 (emptyAtAllAnd e1 True ww1) ww of { False -> sj1; True -> True } };
                      Knight -> let { n = (-) ww3 xk } in let { sj1 = swkingInCheckFromLiftA4 ww4 yk n } in
                      case (<=) n abs1 of { False -> sj1 ((==) n knightmoves1); True -> sj1 ((==) ((-) abs1 n) knightmoves1) };
                      Pawn -> let { n = (-) ww3 xk } in let { sj1 = swkingInCheckFromLiftA6 w ww4 yk } in case (<=) n abs1 of { False -> sj1 ((==) n bishopmoves2); True -> sj1 ((==) ((-) abs1 n) bishopmoves2) } };
kingInCheckFrom w w1 w2 = case w1 of { Board ww1 ww2 -> case w2 of { MkTup ww4 ww5 -> case ww5 of { MkTup ww7 ww8 -> swkingInCheckFrom w ww1 ww2 ww4 ww7 ww8 } } };

swkingincheck w ww ww1 = let { arg = swkingincheckLiftA0 w ww ww1 } in case w of { Black -> any arg ww; White -> any arg ww1 };
swkingincheckLiftA0 w ww ww1 w1 = case w1 of { MkTup ww3 ww4 -> case ww4 of { MkTup ww6 ww7 -> swkingInCheckFrom w ww ww1 ww3 ww6 ww7 } };
kingincheck w w1 = case w1 of { Board ww1 ww2 -> swkingincheck w ww1 ww2 };
swtryMove w ww ww1 ww2 ww3 ww4 ww5 ww6 = let { sj = swtryMoveLiftA0 ww5 ww6 w ww2 ww4 ww3 } in case w of { Black -> sj ww (main72 ww3 ww1); White -> sj (main72 ww3 ww) ww1 };
swtryMoveLiftA1 w ww2 ww3 ww4 ww5 ww6 ww9 ww10 = case swkingincheck w ww9 ww10 of { False -> Cons (MkTup (MoveInFull (MkTup w ww2) ww3 (Move ww4 ww5 ww6)) (Board ww9 ww10)) Nil; True -> Nil };
swtryMoveLiftA2 w sj1 ww4 ww7 ww8 c k = case w of { Black -> case c of { Black -> sj1 (main72 ww4 ww7) (Cons (MkTup k ww4) ww8); White -> sj1 (Cons (MkTup k ww4) (main72 ww4 ww7)) ww8 }; White -> case c of { Black -> sj1 ww7 (Cons (MkTup k ww4) (main72 ww4 ww8)); White -> sj1 (Cons (MkTup k ww4) ww7) (main72 ww4 ww8) } };
swtryMoveLiftA0 ww5 ww6 w ww2 ww4 ww3 ww7 ww8 = let { sj1 = swtryMoveLiftA1 w ww2 ww3 ww4 ww5 ww6 } in case ww5 of { Nothing -> case ww6 of { Nothing -> case w of { Black -> sj1 ww7 (Cons (MkTup ww2 ww4) ww8); White -> sj1 (Cons (MkTup ww2 ww4) ww7) ww8 }; Just x -> case x of { MkTup c k -> case c of { Black -> sj1 ww7 (Cons (MkTup k ww4) ww8); White -> sj1 (Cons (MkTup k ww4) ww7) ww8 } } }; Just x -> let { sj2 = swtryMoveLiftA2 w sj1 ww4 ww7 ww8 } in case ww6 of { Nothing -> sj2 w ww2; Just x1 -> case x1 of { MkTup c k -> sj2 c k } } };
tryMove w w1 w2 w3 = case w1 of { Board ww1 ww2 -> case w2 of { MkTup ww4 ww5 -> case w3 of { Move ww7 ww8 ww9 -> swtryMove w ww1 ww2 ww4 ww5 ww7 ww8 ww9 } } };
swmovesForPiece w w1 ww ww1 = concatMap (swmovesForPieceLiftA0 w1 w ww ww1) (swrawmoves w ww ww1 w1);
swmovesForPieceLiftA0 w1 w ww ww1 w2 = case w1 of { Board ww3 ww4 -> case w2 of { Move ww6 ww7 ww8 -> swtryMove w ww3 ww4 ww ww1 ww6 ww7 ww8 } };
movesForPiece w w1 w2 = case w2 of { MkTup ww1 ww2 -> swmovesForPiece w w1 ww1 ww2 };
moveDetailsFor c bd = case c of { Black -> case bd of { Board wkss bkss -> concatMap (moveDetailsForLiftA0 bd) bkss }; White -> case bd of { Board wkss bkss -> concatMap (moveDetailsForLiftA1 bd) wkss } };
moveDetailsForLiftA0 bd w = case w of { MkTup ww1 ww2 -> swmovesForPiece Black bd ww1 ww2 };
moveDetailsForLiftA1 bd w = case w of { MkTup ww1 ww2 -> swmovesForPiece White bd ww1 ww2 };
mainussswreplies sc sc1 sc2 = let { bd = Board sc2 sc1 } in let { mds = concatMap (mainussswrepliesLiftA0 bd) sc2 } in case (==) sc abs1 of { False -> foldr (mainussswrepliesLiftA1 sc) main73 mds; True -> case mds of { Nil -> main73; Cons x xs -> Nothing } };
mainussswrepliesLiftA0 bd w = case w of { MkTup ww1 ww2 -> swmovesForPiece White bd ww1 ww2 };
mainussswrepliesLiftA1 sc w w1 = case w of { MkTup ww1 ww2 -> case ww2 of { Board ww4 ww5 -> swsolnAnd White sc ww1 ww4 ww5 w1 } };
mainussswreplies1 sc sc1 sc2 = let { bd = Board sc2 sc1 } in let { mds = concatMap (mainussswreplies1LiftA0 bd) sc1 } in case (==) sc abs1 of { False -> foldr (mainussswreplies1LiftA1 sc) main73 mds; True -> case mds of { Nil -> main73; Cons x xs -> Nothing } };
mainussswreplies1LiftA0 bd w = case w of { MkTup ww1 ww2 -> swmovesForPiece Black bd ww1 ww2 };
mainussswreplies1LiftA1 sc w w1 = case w of { MkTup ww1 ww2 -> case ww2 of { Board ww4 ww5 -> swsolnAnd Black sc ww1 ww4 ww5 w1 } };
mainussswsolnOr1 sc sc1 sc2 sc3 sc4 = case mainussswreplies1 ((-) sc4 bishopmoves2) sc1 sc2 of { Nothing -> sc; Just rs -> case rs of { Nil -> case any (mainussswsolnOr1LiftA0 sc2 sc1) sc2 of { False -> sc; True -> Just (Solution sc3 Nil) }; Cons x xs -> Just (Solution sc3 rs) } };
mainussswsolnOr1LiftA0 sc2 sc1 w = case w of { MkTup ww1 ww2 -> case ww2 of { MkTup ww4 ww5 -> swkingInCheckFrom Black sc2 sc1 ww1 ww4 ww5 } };
mainussswsolnOr sc sc1 sc2 sc3 sc4 = case mainussswreplies ((-) sc4 bishopmoves2) sc1 sc2 of { Nothing -> sc; Just rs -> case rs of { Nil -> case any (mainussswsolnOrLiftA0 sc2 sc1) sc1 of { False -> sc; True -> Just (Solution sc3 Nil) }; Cons x xs -> Just (Solution sc3 rs) } };
mainussswsolnOrLiftA0 sc2 sc1 w = case w of { MkTup ww1 ww2 -> case ww2 of { MkTup ww4 ww5 -> swkingInCheckFrom White sc2 sc1 ww1 ww4 ww5 } };
swsolnAnd w w1 ww ww1 ww2 w2 = case w of { Black -> let { w3 = (-) w1 bishopmoves2 } in let { bd = Board ww1 ww2 } in case foldr (swsolnAndLiftA0 w3) Nothing (concatMap (swsolnAndLiftA1 bd) ww1) of { Nothing -> Nothing; Just s -> case w2 of { Nothing -> Nothing; Just ms -> Just (Cons (MkTup ww s) ms) } }; White -> let { w3 = (-) w1 bishopmoves2 } in let { bd = Board ww1 ww2 } in case foldr (swsolnAndLiftA2 w3) Nothing (concatMap (swsolnAndLiftA3 bd) ww2) of { Nothing -> Nothing; Just s -> case w2 of { Nothing -> Nothing; Just ms -> Just (Cons (MkTup ww s) ms) } } };
swsolnAndLiftA0 w3 w4 w5 = case w4 of { MkTup ww4 ww5 -> case ww5 of { Board ww7 ww8 -> mainussswsolnOr1 w5 ww8 ww7 ww4 w3 } };
swsolnAndLiftA1 bd w4 = case w4 of { MkTup ww4 ww5 -> swmovesForPiece White bd ww4 ww5 };
swsolnAndLiftA2 w3 w4 w5 = case w4 of { MkTup ww4 ww5 -> case ww5 of { Board ww7 ww8 -> mainussswsolnOr w5 ww8 ww7 ww4 w3 } };
swsolnAndLiftA3 bd w4 = case w4 of { MkTup ww4 ww5 -> swmovesForPiece Black bd ww4 ww5 };
swsolnOr w w1 ww ww1 ww2 w2 = let { sj = swsolnOrLiftA0 w ww2 w2 ww ww1 } in case w of { Black -> case mainussswreplies ((-) w1 bishopmoves2) ww2 ww1 of { Nothing -> w2; Just rs -> sj rs }; White -> case mainussswreplies1 ((-) w1 bishopmoves2) ww2 ww1 of { Nothing -> w2; Just rs -> sj rs } };
swsolnOrLiftA1 w3 ww1 ww2 w4 = case w4 of { MkTup ww4 ww5 -> case ww5 of { MkTup ww7 ww8 -> swkingInCheckFrom w3 ww1 ww2 ww4 ww7 ww8 } };
swsolnOrLiftA0 w ww2 w2 ww ww1 rs = case rs of { Nil -> let { w3 = case w of { Black -> White; White -> Black } } in let { arg = swsolnOrLiftA1 w3 ww1 ww2 } in case w of { Black -> case any arg ww2 of { False -> w2; True -> Just (Solution ww Nil) }; White -> case any arg ww1 of { False -> w2; True -> Just (Solution ww Nil) } }; Cons x xs -> Just (Solution ww rs) };
solnAnd w w1 w2 w3 = case w2 of { MkTup ww1 ww2 -> case ww2 of { Board ww4 ww5 -> swsolnAnd w w1 ww1 ww4 ww5 w3 } };
swreplies ww ww1 w w1 = let { bd = Board ww ww1 } in let { sj = swrepliesLiftA0 w1 w } in case w of { Black -> sj (concatMap (swrepliesLiftA1 bd) ww1); White -> sj (concatMap (swrepliesLiftA2 bd) ww) };
swrepliesLiftA0 w1 w mds = case (==) w1 abs1 of { False -> foldr (solnAnd w w1) main73 mds; True -> case mds of { Nil -> main73; Cons x xs -> Nothing } };
swrepliesLiftA1 bd w2 = case w2 of { MkTup ww3 ww4 -> swmovesForPiece Black bd ww3 ww4 };
swrepliesLiftA2 bd w2 = case w2 of { MkTup ww3 ww4 -> swmovesForPiece White bd ww3 ww4 };
solnOr w w1 w2 w3 = case w2 of { MkTup ww1 ww2 -> case ww2 of { Board ww4 ww5 -> swsolnOr w w1 ww1 ww4 ww5 w3 } };
solution bd c n = case c of { Black -> case bd of { Board wkss bkss -> foldr (solutionLiftA0 n) Nothing (concatMap (solutionLiftA1 bd) bkss) }; White -> case bd of { Board wkss bkss -> foldr (solutionLiftA2 n) Nothing (concatMap (solutionLiftA3 bd) wkss) } };
solutionLiftA0 n w w1 = case w of { MkTup ww1 ww2 -> case ww2 of { Board ww4 ww5 -> mainussswsolnOr w1 ww5 ww4 ww1 n } };
solutionLiftA1 bd w = case w of { MkTup ww1 ww2 -> swmovesForPiece Black bd ww1 ww2 };
solutionLiftA2 n w w1 = case w of { MkTup ww1 ww2 -> case ww2 of { Board ww4 ww5 -> mainussswsolnOr1 w1 ww5 ww4 ww1 n } };
solutionLiftA3 bd w = case w of { MkTup ww1 ww2 -> swmovesForPiece White bd ww1 ww2 };
replies w w1 w2 = case w of { Board ww1 ww2 -> swreplies ww1 ww2 w1 w2 };
swsolve ww ww1 w w1 = let { w2 = (-) ((+) w1 w1) bishopmoves2 } in let { arg = swsolveLiftA0 w w2 } in let { bd = Board ww ww1 } in case w of { Black -> case foldr arg Nothing (concatMap (swsolveLiftA1 bd) ww1) of { Nothing -> abs1; Just s -> size s }; White -> case foldr arg Nothing (concatMap (swsolveLiftA2 bd) ww) of { Nothing -> abs1; Just s -> size s } };
swsolveLiftA0 w w2 w3 w4 = case w3 of { MkTup ww3 ww4 -> case ww4 of { Board ww6 ww7 -> swsolnOr w w2 ww3 ww6 ww7 w4 } };
swsolveLiftA1 bd w3 = case w3 of { MkTup ww3 ww4 -> swmovesForPiece Black bd ww3 ww4 };
swsolveLiftA2 bd w3 = case w3 of { MkTup ww3 ww4 -> swmovesForPiece White bd ww3 ww4 };
solve w w1 w2 = case w of { Board ww1 ww2 -> swsolve ww1 ww2 w1 w2 };
solveProblem ds = case ds of { MkTup bd ds1 -> case ds1 of { MkTup c n -> solve bd c n } };
main55  = MkTup main26 bishopmoves2;
main54  = MkTup Queen main55;
main53  = Cons main54 Nil;
main52  = Cons main56 main53;
main51  = Cons main58 main52;
main50  = Cons main60 main51;
main49  = Cons main62 main50;
main48  = Cons main64 main49;
main47  = Cons main66 main48;
main46  = Cons main68 main47;
main45  = Cons main70 main46;
main20  = MkTup bishopmoves2 bishopmoves2;
main19  = MkTup Queen main20;
main18  = MkTup knightmoves1 bishopmoves2;
main17  = MkTup Knight main18;
main16  = MkTup moveLine1 bishopmoves2;
main15  = MkTup Bishop main16;
main14  = Cons main15 Nil;
main13  = Cons main17 main14;
main12  = Cons main19 main13;
main11  = Cons main21 main12;
main10  = Cons main24 main11;
main9  = Cons main27 main10;
main8  = Cons main29 main9;
main7  = Cons main32 main8;
main6  = Cons main34 main7;
main5  = Cons main37 main6;
main4  = Cons main39 main5;
main3  = Cons main41 main4;
main2  = Cons main43 main3;
main  = swsolve main45 main2 White main1;
const c x = c;
id x = x;
}
