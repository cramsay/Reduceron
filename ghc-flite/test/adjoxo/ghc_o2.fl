{
map f ds = case ds of { Nil -> Nil; Cons x xs -> Cons (f x) (map f xs) };
bestOf ds v = case ds of { Win -> Win; Loss -> v; Draw -> case v of { Win -> Win; Loss -> Draw; Draw -> Draw } };
inverse ds = case ds of { Win -> Loss; Loss -> Win; Draw -> Draw };
adjudicate22  = 1;
fromTozfromTo n m = case (<=) n m of { False -> Nil; True -> Cons n (fromTozfromTo ((+) n adjudicate22) m) };
swfromTo ww w w1 w2 = let { lvl1 = w adjudicate22 } in let { fromTo1 = swfromTozliftA0 ww fromTo1 w lvl1 } in fromTo1 w1 w2;
swfromTozliftA0 ww fromTo1 w lvl1 n m = case ww n m of { False -> Nil; True -> Cons n (fromTo1 ((+) w n lvl1) m) };
fromTo w w1 w2 w3 = case w of { COrd ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 -> swfromTo ww4 w1 w2 w3 };
swcmp ww ww1 w w1 = case ww w w1 of { False -> case ww1 w w1 of { False -> GT; True -> LT }; True -> EQ };
cmp w w1 w2 = case w of { COrd ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 -> case ww1 of { CEq ww10 ww11 -> swcmp ww10 ww4 w1 w2 } };
diffzssdiff1 sc sc1 sc2 = case sc2 of { Nil -> Nil; Cons x xs -> case (==) x sc of { False -> case (<=) x sc of { False -> adjudicatezssdiff sc1 x xs; True -> Cons x (diffzssdiff1 sc sc1 xs) }; True -> diffzdiff xs sc1 } };
diffzdiff ds ys = case ds of { Nil -> Nil; Cons x xs -> case ys of { Nil -> ds; Cons y ys1 -> case (==) x y of { False -> case (<=) x y of { False -> adjudicatezssdiff ys1 x xs; True -> Cons x (diffzssdiff1 y ys1 xs) }; True -> diffzdiff xs ys1 } } };
adjudicatezssdiff sc sc1 sc2 = case sc of { Nil -> Cons sc1 sc2; Cons y ys -> case (==) sc1 y of { False -> case (<=) sc1 y of { False -> adjudicatezssdiff ys sc1 sc2; True -> Cons sc1 (diffzssdiff1 y ys sc2) }; True -> diffzdiff sc2 ys } };
diff eta eta1 = let { lvl1 = Nil } in let { ssdiff = diffzliftA0 lvl1 ssdiff ssdiff1 diff1; diff1 = diffzliftA1 lvl1 ssdiff ssdiff1 diff1; ssdiff1 = diffzliftA2 lvl1 ssdiff ssdiff1 diff1 } in diff1 eta eta1;
diffzliftA0 lvl1 ssdiff ssdiff1 diff1 sc sc1 sc2 = case sc of { Nil -> Cons sc1 sc2; Cons y ys -> case (==) sc1 y of { False -> case (<=) sc1 y of { False -> ssdiff ys sc1 sc2; True -> Cons sc1 (ssdiff1 y ys sc2) }; True -> diff1 sc2 ys } };
diffzliftA1 lvl1 ssdiff ssdiff1 diff1 ds ys = case ds of { Nil -> Nil; Cons x xs -> case ys of { Nil -> ds; Cons y ys1 -> case (==) x y of { False -> case (<=) x y of { False -> ssdiff ys1 x xs; True -> Cons x (ssdiff1 y ys1 xs) }; True -> diff1 xs ys1 } } };
diffzliftA2 lvl1 ssdiff ssdiff1 diff1 sc sc1 sc2 = case sc2 of { Nil -> Nil; Cons x xs -> case (==) x sc of { False -> case (<=) x sc of { False -> ssdiff sc1 x xs; True -> Cons x (ssdiff1 sc sc1 xs) }; True -> diff1 xs sc1 } };
insertzinsert w w1 = case swinsert w w1 of { MkPair ww1 ww2 -> Cons ww1 ww2 };
swinsert w w1 = case w1 of { Nil -> MkPair w Nil; Cons y ys -> case (<=) w y of { False -> MkPair y (insertzinsert w ys); True -> MkPair w w1 } };
insert eta eta1 = let { insert1 = insertzliftA0 insert1 } in insert1 eta eta1;
insertzliftA0 insert1 x ds = case ds of { Nil -> Cons x Nil; Cons y ys -> case (<=) x y of { False -> Cons y (insert1 x ys); True -> Cons x ds } };
adjudicatezssfoldr2 sc sc1 = case sc1 of { Nil -> sc; Cons y ys -> case sc of { Win -> Win; Loss -> adjudicatezssfoldr2 y ys; Draw -> case adjudicatezssfoldr2 y ys of { Win -> Win; Loss -> Draw; Draw -> Draw } } };
adjudicatezssfoldr1 sc = case sc of { Nil -> Win; Cons x ds -> case ds of { Nil -> x; Cons y ys -> case x of { Win -> Win; Loss -> adjudicatezssfoldr2 y ys; Draw -> case adjudicatezssfoldr2 y ys of { Win -> Win; Loss -> Draw; Draw -> Draw } } } };
foldr1zssfoldr1 sc sc1 sc2 = case sc1 of { Nil -> sc; Cons y ys -> sc2 sc (foldr1zssfoldr1 y ys sc2) };
foldr1 f ds = case ds of { Nil -> Win; Cons x ds1 -> case ds1 of { Nil -> x; Cons y ys -> f x (foldr1zssfoldr1 y ys f) } };
null ds = case ds of { Nil -> True; Cons x xs -> False };
subset xs ys = case diff xs ys of { Nil -> True; Cons x xs1 -> False };
or ds x = case ds of { False -> x; True -> True };
adjudicate10  = 3;
adjudicate4  = 5;
adjudicate3  = 7;
adjudicate2  = Cons adjudicate3 Nil;
adjudicate1  = Cons adjudicate4 adjudicate2;
adjudicate7  = 9;
adjudicate6  = Cons adjudicate7 Nil;
adjudicate5  = Cons adjudicate4 adjudicate6;
adjudicate9  = 6;
adjudicate8  = Cons adjudicate9 adjudicate6;
adjudicate14  = 2;
adjudicate13  = 8;
adjudicate12  = Cons adjudicate13 Nil;
adjudicate11  = Cons adjudicate4 adjudicate12;
adjudicate16  = 4;
adjudicate15  = Cons adjudicate16 adjudicate2;
adjudicate17  = Cons adjudicate13 adjudicate6;
adjudicate19  = Cons adjudicate9 Nil;
adjudicate18  = Cons adjudicate4 adjudicate19;
adjudicate21  = Cons adjudicate10 Nil;
adjudicate20  = Cons adjudicate14 adjudicate21;
adjudicatezsshasLine p = case adjudicatezssdiff p adjudicate22 adjudicate20 of { Nil -> True; Cons x xs -> case adjudicatezssdiff p adjudicate16 adjudicate18 of { Nil -> True; Cons x1 xs1 -> case adjudicatezssdiff p adjudicate3 adjudicate17 of { Nil -> True; Cons x2 xs2 -> case adjudicatezssdiff p adjudicate22 adjudicate15 of { Nil -> True; Cons x3 xs3 -> case adjudicatezssdiff p adjudicate14 adjudicate11 of { Nil -> True; Cons x4 xs4 -> case adjudicatezssdiff p adjudicate10 adjudicate8 of { Nil -> True; Cons x5 xs5 -> case adjudicatezssdiff p adjudicate22 adjudicate5 of { Nil -> True; Cons x6 xs6 -> case adjudicatezssdiff p adjudicate10 adjudicate1 of { Nil -> True; Cons x7 xs7 -> False } } } } } } } };
hasLine p = case diff (Cons (adjudicate22) (Cons (adjudicate14) (Cons (adjudicate10) Nil))) p of { Nil -> True; Cons x xs -> case diff (Cons (adjudicate16) (Cons (adjudicate4) (Cons (adjudicate9) Nil))) p of { Nil -> True; Cons x1 xs1 -> case diff (Cons (adjudicate3) (Cons (adjudicate13) (Cons (adjudicate7) Nil))) p of { Nil -> True; Cons x2 xs2 -> case diff (Cons (adjudicate22) (Cons (adjudicate16) (Cons (adjudicate3) Nil))) p of { Nil -> True; Cons x3 xs3 -> case diff (Cons (adjudicate14) (Cons (adjudicate4) (Cons (adjudicate13) Nil))) p of { Nil -> True; Cons x4 xs4 -> case diff (Cons (adjudicate10) (Cons (adjudicate9) (Cons (adjudicate7) Nil))) p of { Nil -> True; Cons x5 xs5 -> case diff (Cons (adjudicate22) (Cons (adjudicate4) (Cons (adjudicate7) Nil))) p of { Nil -> True; Cons x6 xs6 -> case diff (Cons (adjudicate10) (Cons (adjudicate4) (Cons (adjudicate3) Nil))) p of { Nil -> True; Cons x7 xs7 -> False } } } } } } } };
lengthAcc eta eta1 = let { lvl1 = adjudicate22 } in let { lengthAcc2 = lengthAcczliftA0 lengthAcc2 lvl1 } in lengthAcc2 eta eta1;
lengthAcczliftA0 lengthAcc2 lvl1 acc ds = case ds of { Nil -> acc; Cons x xs -> lengthAcc2 ((+) lvl1 acc) xs };
adjudicate23  = 0;
length xs = let { lvl1 = adjudicate22 } in let { lengthAcc2 = lengthzliftA0 lengthAcc2 lvl1 } in lengthAcc2 (adjudicate23) xs;
lengthzliftA0 lengthAcc2 lvl1 acc ds = case ds of { Nil -> acc; Cons x xs1 -> lengthAcc2 ((+) lvl1 acc) xs1 };
--
--gridFull ap pp = let { sj = gridFullzliftA0 adjudicate23 ap (+) adjudicate22 } in let { lengthAcc2 = gridFullzliftA3 sj lengthAcc2 (+) adjudicate22 } in lengthAcc2 adjudicate23 pp;
--gridFullzliftA1 acc = acc;
--gridFullzliftA2 exit lengthAcc2 (+) adjudicate22 acc ds = case ds of { Nil -> exit acc; Cons x xs -> lengthAcc2 ((+) adjudicate22 acc) xs };
--gridFullzliftA0 adjudicate23 ap (+) adjudicate22 karg = let { exit = gridFullzliftA1 } in let { lengthAcc2 = gridFullzliftA2 exit lengthAcc2 (+) adjudicate22 } in lengthAcc2 adjudicate23 ap;
--gridFullzliftA3 sj lengthAcc2 (+) adjudicate22 acc ds = case ds of { Nil -> sj acc; Cons x xs -> lengthAcc2 ((+) adjudicate22 acc) xs };
gridFull ap pp = (==) ((+) (length ap) (length pp)) 9;

lvl  = fromTozfromTo adjudicate22 adjudicate7;
analysiszmoveval ap pp m = case adjudicatezanalysis pp (insertzinsert m ap) of { Win -> Loss; Loss -> Win; Draw -> Draw };
adjudicatezanalysis ap pp = case adjudicatezsshasLine pp of { False -> case gridFull ap pp of { False -> adjudicatezssfoldr1 (map (analysiszmoveval ap pp) (diffzdiff (diffzdiff lvl ap) pp)); True -> Draw }; True -> Loss };
swds w w1 = let { lvl1 = case w of { COrd ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 -> swfromTo ww4 w1 (w1 adjudicate22) (w1 adjudicate7) } } in let { moveval1 = swdszliftA0 analysis2 insert w; analysis2 = swdszliftA1 hasLine w w1 gridFull adjudicatezssfoldr1 map moveval1 diff lvl1 } in MkPair analysis2 moveval1;
swdszliftA0 analysis2 insert w ap pp m = case analysis2 pp (insert w m ap) of { Win -> Loss; Loss -> Win; Draw -> Draw };
swdszliftA1 hasLine w w1 gridFull adjudicatezssfoldr1 map moveval1 diff lvl1 ap pp = case hasLine w w1 pp of { False -> case gridFull ap pp of { False -> adjudicatezssfoldr1 (map (moveval1 ap pp) (diff w (diff w lvl1 ap) pp)); True -> Draw }; True -> Loss };
analysis1 w w1 = case swds w w1 of { MkPair ww1 ww2 -> MkPair ww1 ww2 };
analysis  = case swds of { MkPair ww1 ww2 -> ww1 };
moveval  = case swds of { MkPair ww1 ww2 -> ww2 };
opp ds = case ds of { O -> X; X -> O };
side ds = case ds of { O -> adjudicate23; X -> adjudicate22 };
report ds s = case ds of { Win -> case s of { O -> adjudicate23; X -> adjudicate22 }; Loss -> case s of { O -> adjudicate22; X -> adjudicate23 }; Draw -> adjudicate10 };
adjudicatezssadjudicate os xs = let { sj = adjudicatezssadjudicatezliftA0 adjudicate23 os adjudicate22 adjudicatezanalysis xs adjudicate10 adjudicatezsshasLine } in let { lengthAcc2 = adjudicatezssadjudicatezliftA3 sj lengthAcc2 adjudicate22 } in lengthAcc2 adjudicate23 xs;
adjudicatezssadjudicatezliftA1 eta adjudicatezanalysis xs os adjudicate22 adjudicate23 adjudicate10 adjudicatezsshasLine eta1 = case (==) eta1 eta of { False -> case (<=) eta1 eta of { False -> case adjudicatezanalysis xs os of { Win -> adjudicate22; Loss -> adjudicate23; Draw -> adjudicate10 }; True -> case adjudicatezanalysis os xs of { Win -> adjudicate23; Loss -> adjudicate22; Draw -> adjudicate10 } }; True -> case adjudicatezsshasLine xs of { False -> case adjudicatezsshasLine os of { False -> case adjudicatezanalysis xs os of { Win -> adjudicate22; Loss -> adjudicate23; Draw -> adjudicate10 }; True -> adjudicate23 }; True -> adjudicate22 } };
adjudicatezssadjudicatezliftA2 sj1 lengthAcc2 adjudicate22 acc ds = case ds of { Nil -> sj1 acc; Cons x xs1 -> lengthAcc2 ((+) adjudicate22 acc) xs1 };
adjudicatezssadjudicatezliftA0 adjudicate23 os adjudicate22 adjudicatezanalysis xs adjudicate10 adjudicatezsshasLine eta = let { sj1 = adjudicatezssadjudicatezliftA1 eta adjudicatezanalysis xs os adjudicate22 adjudicate23 adjudicate10 adjudicatezsshasLine } in let { lengthAcc2 = adjudicatezssadjudicatezliftA2 sj1 lengthAcc2 adjudicate22 } in lengthAcc2 adjudicate23 os;
adjudicatezssadjudicatezliftA3 sj lengthAcc2 adjudicate22 acc ds = case ds of { Nil -> sj acc; Cons x xs1 -> lengthAcc2 ((+) adjudicate22 acc) xs1 };
adjudicate os xs = let { sj = adjudicatezliftA0 adjudicate23 os adjudicate22 swds xs adjudicate10 hasLine } in let { lengthAcc2 = adjudicatezliftA3 sj lengthAcc2 adjudicate22 } in lengthAcc2 adjudicate23 xs;
adjudicatezliftA1 eta swds xs os adjudicate22 adjudicate23 adjudicate10 hasLine eta1 = case eta1 eta of { False -> case (<=) eta1 eta of { False -> case swds of { MkPair ww1 ww2 -> case ww1 xs os of { Win -> adjudicate22; Loss -> adjudicate23; Draw -> adjudicate10 } }; True -> case swds of { MkPair ww1 ww2 -> case ww1 os xs of { Win -> adjudicate23; Loss -> adjudicate22; Draw -> adjudicate10 } } }; True -> case hasLine xs of { False -> case hasLine os of { False -> case swds of { MkPair ww1 ww2 -> case ww1 xs os of { Win -> adjudicate22; Loss -> adjudicate23; Draw -> adjudicate10 } }; True -> adjudicate23 }; True -> adjudicate22 } };
adjudicatezliftA2 sj1 lengthAcc2 adjudicate22 acc ds = case ds of { Nil -> sj1 acc; Cons x xs1 -> lengthAcc2 ((+) adjudicate22 acc) xs1 };
adjudicatezliftA0 adjudicate23 os adjudicate22 swds xs adjudicate10 hasLine eta = let { sj1 = adjudicatezliftA1 eta swds xs os adjudicate22 adjudicate23 adjudicate10 hasLine } in let { lengthAcc2 = adjudicatezliftA2 sj1 lengthAcc2 adjudicate22 } in lengthAcc2 adjudicate23 os;
adjudicatezliftA3 sj lengthAcc2 adjudicate22 acc ds = case ds of { Nil -> sj acc; Cons x xs1 -> lengthAcc2 ((+) adjudicate22 acc) xs1 };
main  = adjudicatezssadjudicate Nil Nil;
}
