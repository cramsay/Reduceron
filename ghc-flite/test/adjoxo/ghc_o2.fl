{
map f ds = case ds of { Nil -> Nil; Cons x xs -> Cons (f x) (map f xs) };
bestOf ds v = case ds of { Win -> Win; Loss -> v; Draw -> case v of { Win -> Win; Loss -> Draw; Draw -> Draw } };
inverse ds = case ds of { Win -> Loss; Loss -> Win; Draw -> Draw };
insertuinsert w w1 = case swinsert w w1 of { MkTup ww1 ww2 -> Cons ww1 ww2 };
swinsert w w1 = case w1 of { Nil -> MkTup w Nil; Cons y ys -> case (<=) w y of { False -> MkTup y (insertuinsert w ys); True -> MkTup w w1 } };
insert eta eta1 = let { insert1 = insertLiftA0 } in insert1 eta eta1;
insertLiftA0 x ds = case ds of { Nil -> Cons x Nil; Cons y ys -> case (<=) x y of { False -> Cons y (insertLiftA0 x ys); True -> Cons x ds } };
foldr1ussfoldr1 sc sc1 sc2 = case sc1 of { Nil -> sc; Cons y ys -> sc2 sc (foldr1ussfoldr1 y ys sc2) };
foldr1 f ds = case ds of { Nil -> Win; Cons x ds1 -> case ds1 of { Nil -> x; Cons y ys -> f x (foldr1ussfoldr1 y ys f) } };
null ds = case ds of { Nil -> True; Cons x xs -> False };
or ds x = case ds of { False -> x; True -> True };
opp ds = case ds of { O -> X; X -> O };
adjudicate1  = 0;
hasLine22  = 1;
side ds = case ds of { O -> adjudicate1; X -> hasLine22 };
cmp a b = case (==) a b of { False -> case (<=) a b of { False -> GT; True -> LT }; True -> EQ };
diff ds ys = case ds of { Nil -> Nil; Cons x xs -> case ys of { Nil -> ds; Cons y ys1 -> case (==) x y of { False -> case (<=) x y of { False -> hasLineussdiff ys1 x xs; True -> Cons x (diffussdiff y ys1 xs) }; True -> diff xs ys1 } } };
hasLineussdiff sc sc1 sc2 = case sc of { Nil -> Cons sc1 sc2; Cons y ys -> case (==) sc1 y of { False -> case (<=) sc1 y of { False -> hasLineussdiff ys sc1 sc2; True -> Cons sc1 (diffussdiff y ys sc2) }; True -> diff sc2 ys } };
diffussdiff sc sc1 sc2 = case sc2 of { Nil -> Nil; Cons x xs -> case (==) x sc of { False -> case (<=) x sc of { False -> hasLineussdiff sc1 x xs; True -> Cons x (diffussdiff sc sc1 xs) }; True -> diff xs sc1 } };
subset xs ys = case diff xs ys of { Nil -> True; Cons x xs1 -> False };
hasLine10  = 3;
hasLine4  = 5;
hasLine3  = 7;
hasLine2  = Cons hasLine3 Nil;
hasLine1  = Cons hasLine4 hasLine2;
hasLine7  = 9;
hasLine6  = Cons hasLine7 Nil;
hasLine5  = Cons hasLine4 hasLine6;
hasLine9  = 6;
hasLine8  = Cons hasLine9 hasLine6;
hasLine14  = 2;
hasLine13  = 8;
hasLine12  = Cons hasLine13 Nil;
hasLine11  = Cons hasLine4 hasLine12;
hasLine16  = 4;
hasLine15  = Cons hasLine16 hasLine2;
hasLine17  = Cons hasLine13 hasLine6;
hasLine19  = Cons hasLine9 Nil;
hasLine18  = Cons hasLine4 hasLine19;
hasLine21  = Cons hasLine10 Nil;
hasLine20  = Cons hasLine14 hasLine21;
hasLine p = case hasLineussdiff p hasLine22 hasLine20 of { Nil -> True; Cons x xs -> case hasLineussdiff p hasLine16 hasLine18 of { Nil -> True; Cons x1 xs1 -> case hasLineussdiff p hasLine3 hasLine17 of { Nil -> True; Cons x2 xs2 -> case hasLineussdiff p hasLine22 hasLine15 of { Nil -> True; Cons x3 xs3 -> case hasLineussdiff p hasLine14 hasLine11 of { Nil -> True; Cons x4 xs4 -> case hasLineussdiff p hasLine10 hasLine8 of { Nil -> True; Cons x5 xs5 -> case hasLineussdiff p hasLine22 hasLine5 of { Nil -> True; Cons x6 xs6 -> case hasLineussdiff p hasLine10 hasLine1 of { Nil -> True; Cons x7 xs7 -> False } } } } } } } };
lengthAcc acc ds = case ds of { Nil -> acc; Cons x xs -> lengthAcc ((+) hasLine22 acc) xs };
length xs = lengthAcc adjudicate1 xs;
gridFull ap pp = (==) ((+) (length ap) (length pp)) 9;
report ds s = case ds of { Win -> case s of { O -> adjudicate1; X -> hasLine22 }; Loss -> case s of { O -> hasLine22; X -> adjudicate1 }; Draw -> hasLine10 };
fromTo n m = case (<=) n m of { False -> Nil; True -> Cons n (fromTo ((+) n hasLine22) m) };
lvl  = fromTo hasLine22 hasLine7;
moveval ap pp m = case analysis pp (insertuinsert m ap) of { Win -> Loss; Loss -> Win; Draw -> Draw };
analysis ap pp = case hasLine pp of { False -> case gridFull ap pp of { False -> case map (moveval ap pp) (diff (diff lvl ap) pp) of { Nil -> Win; Cons x ds -> case ds of { Nil -> x; Cons y ys -> case x of { Win -> Win; Loss -> foldr1ussfoldr1 y ys bestOf; Draw -> case foldr1ussfoldr1 y ys bestOf of { Win -> Win; Loss -> Draw; Draw -> Draw } } } }; True -> Draw }; True -> Loss };
adjudicate os xs = let { a = lengthAcc adjudicate1 os } in let { b = lengthAcc adjudicate1 xs } in case (==) a b of { False -> case (<=) a b of { False -> case analysis xs os of { Win -> hasLine22; Loss -> adjudicate1; Draw -> hasLine10 }; True -> case analysis os xs of { Win -> adjudicate1; Loss -> hasLine22; Draw -> hasLine10 } }; True -> case hasLine xs of { False -> case hasLine os of { False -> case analysis xs os of { Win -> hasLine22; Loss -> adjudicate1; Draw -> hasLine10 }; True -> adjudicate1 }; True -> hasLine22 } };
main  = adjudicate Nil Nil;
}
